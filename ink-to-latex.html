<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ABS Flashcards System</title>
  <!-- Elegant font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&display=swap" rel="stylesheet">
  <!-- MathJax for LaTeX rendering -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Verify D3.js is loaded
    window.addEventListener('load', function() {
      if (typeof d3 === 'undefined') {
        console.error('D3.js is not loaded properly');
      }
    });
  </script>
 <style>
    * {
        box-sizing: border-box;
    }
    /* Header Styling */
/* Define CSS Variables for Consistency and Maintainability */
:root {
    --primary-color: #6fc5bb;
    --primary-color-dark: #0069d9;
    --danger-color: #dc3545;
    --danger-color-dark: #c82333;
    --success-color: #28a745;
    --success-color-dark: #218838;
    --background-color: #f8f9fa;
    --text-color: #333;
    --border-color: #76797c;
    --border-radius: 8px;
    --transition-duration: 0.2s;
    --box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    --button-padding: 12px 24px;
    --input-padding: 12px 18px;
    --font-size-base: 15px;
    --font-weight-medium: 500;
}

/* Header Styles */
header {
    text-align: center;
    margin-bottom: 30px;
}

header h1 {
    font-size: 2.8em;
    margin: 0;
    color: var(--text-color);
    font-weight: 600;
    letter-spacing: -0.5px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

@keyframes glow {
    0% { text-shadow: 0 0 10px rgba(0, 0, 0, 0.1); }
    100% { text-shadow: 0 0 20px rgba(0, 0, 0, 0.2); }
}

/* Global Styles */
body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--background-color);
    margin: 0;
    padding: 40px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
    color: var(--text-color);
    line-height: 1.5;
    font-size: 16px;
}

/* Controls Section */
.controls {
    display: flex;
    gap: 15px;
    margin-bottom: 40px;
    flex-wrap: wrap;
    justify-content: center;
    background: #fff;
    padding: 24px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
}

.controls input[type="text"],
.controls select {
    padding: var(--input-padding);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    font-size: var(--font-size-base);
    transition: all var(--transition-duration) ease;
    background: #fff;
    color: var(--text-color);
}

.controls input[type="text"]:focus,
.controls select:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    outline: none;
}

.controls button {
    padding: var(--button-padding);
    background: var(--primary-color);
    border: none;
    border-radius: var(--border-radius);
    color: white;
    font-size: var(--font-size-base);
    font-weight: var(--font-weight-medium);
    cursor: pointer;
    transition: all var(--transition-duration) ease;
    box-shadow: var(--box-shadow);
}

.controls button:hover {
    background: var(--primary-color-dark);
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 123, 255, 0.2);
}

/* Flashcard Container */
.flashcard-container {
    display: flex;
    flex-wrap: wrap;
    gap: 24px;
    justify-content: center;
    width: 100%;
    max-width: 1200px;
    padding: 20px;
}

/* Flashcard Styling */
.flashcard {
    min-width: 340px;
    min-height: 240px;
    max-width: 400px;
    width: auto;
    height: auto;
    perspective: 1000px;
    position: relative;
    cursor: pointer;
    margin: 15px;
    flex: 1 1 auto;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.flashcard-inner {
    position: relative;
    width: 100%;
    height: 100%;
    min-height: 180px;
    transition: transform 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
    transform-style: preserve-3d;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
    border-radius: var(--border-radius);
    background: #fff;
    border: 1px solid var(--border-color);
}

.flashcard.flipped .flashcard-inner {
    transform: rotateY(180deg);
}

.flashcard-front,
.flashcard-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 32px 24px;
    box-sizing: border-box;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 17px;
    text-align: center;
    overflow-y: auto;
}

.flashcard-front > *,
.flashcard-back {
    justify-content: flex-start;
    text-align: left;
    padding-top: 24px;
}

.flashcard-front {
    background: linear-gradient(145deg, #ffffff, #f5f7fa);
    color: var(--text-color);
}

.flashcard-back {
    background: linear-gradient(145deg, #f5f7fa, #edf2f7);
    color: var(--text-color);
    transform: rotateY(180deg);
}

/* Note Card Styling */
.flashcard.note {
    min-width: 400px;
    min-height: 300px;
}

.flashcard.note .flashcard-back {
    background: linear-gradient(145deg, #f8f9fa, #edf2f7);
    color: var(--text-color);
    transform: rotateY(180deg);
}

/* Edit Mode Styling */
.edit-mode {
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: #fff;
    border-radius: var(--border-radius);
    padding: 20px;
    box-shadow: var(--box-shadow);
    width: 100%;
    box-sizing: border-box;
    transition: all 0.3s cubic-bezier(0.165, 0.84, 0.44, 1);
    height: 100%;
    overflow: hidden;
    opacity: 0;
}

.edit-mode.expanded {
    max-height: 1000px;
    opacity: 1;
    padding: 24px;
}

.edit-mode input,
.edit-mode textarea {
    width: 100%;
    padding: 12px;
    margin-bottom: 16px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: var(--font-size-base);
    transition: all var(--transition-duration) ease;
    box-sizing: border-box;
    background: #fff;
    color: var(--text-color);
}

.edit-mode textarea {
    min-height: 120px;
    resize: vertical;
}

.edit-mode input:focus,
.edit-mode textarea:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    outline: none;
}

.edit-mode .button-group {
    display: flex;
    gap: 12px;
    margin-top: 16px;
}

.edit-mode .save-btn,
.edit-mode .cancel-btn {
    padding: var(--button-padding);
    border: none;
    border-radius: var(--border-radius);
    font-size: var(--font-size-base);
    font-weight: var(--font-weight-medium);
    cursor: pointer;
    transition: all var(--transition-duration) ease;
    flex: 1;
}

.edit-mode .save-btn {
    background: var(--primary-color);
    color: white;
}

.edit-mode .cancel-btn {
    background: var(--danger-color);
    color: white;
}

.edit-mode .save-btn:hover,
.edit-mode .cancel-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}

.edit-mode .subcards-section {
    margin-top: 24px;
    padding-top: 24px;
    border-top: 1px solid var(--border-color);
}

.edit-mode .subcards-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.edit-mode .add-subcard-btn {
    padding: 8px 16px;
    background: var(--success-color);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all var(--transition-duration) ease;
}

.edit-mode .add-subcard-btn:hover {
    background: var(--success-color-dark);
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(40, 167, 69, 0.2);
}

/* Delete & Edit Buttons */
.delete-btn,
.edit-btn {
    position: absolute;
    top: 12px;
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    cursor: pointer;
    opacity: 0;
    transition: all var(--transition-duration) ease;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
}

.delete-btn {
    right: 12px;
    background: var(--danger-color);
    box-shadow: 0 2px 6px rgba(220, 53, 69, 0.2);
    color: white;
}

.edit-btn {
    right: 52px;
    background: var(--primary-color);
    box-shadow: 0 2px 6px rgba(0, 123, 255, 0.2);
    color: white;
}

.flashcard:hover .delete-btn,
.flashcard:hover .edit-btn {
    opacity: 1;
}

.delete-btn:hover,
.edit-btn:hover {
    filter: brightness(1.1);
}

/* Subcards Container */
.subcards-container {
    margin: 10px 0;
    padding: 10px;
    background: #f5f5f5;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    max-height: 400px;
    overflow-y: auto;
}

/* Subcard Styling */
.flashcard.subcard {
    min-width: 200px;
    min-height: 140px;
    max-width: 300px;
    position: relative;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-clip: padding-box;
    cursor: pointer;
    perspective: 800px;
}

.flashcard.subcard .flashcard-back {
    background: linear-gradient(145deg, #f8f9fa, #edf2f7);
    color: var(--text-color);
}

/* Modal Styling for Subcards */
#subcardsModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    backdrop-filter: blur(8px);
}

#subcardsModal .modal-content {
    background: #fff;
    padding: 24px;
    border-radius: var(--border-radius);
    max-width: 80%;
    max-height: 80%;
    overflow-y: auto;
    position: relative;
    animation: fadeInScale 0.3s cubic-bezier(0.165, 0.84, 0.44, 1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}

.close-modal {
    position: absolute;
    top: 12px;
    right: 12px;
    background: var(--danger-color);
    color: white;
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-subcards-container {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    justify-content: center;
    margin-top: 40px;
}

/* Modal Styling for Expanded Note */
#noteModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 3000;
    backdrop-filter: blur(8px);
}

#noteModal .modal-content {
    background: #fff;
    color: var(--text-color);
    padding: 32px;
    border-radius: var(--border-radius);
    max-width: 90%;
    max-height: 90%;
    overflow-y: auto;
    position: relative;
    animation: fadeInScale 0.3s cubic-bezier(0.165, 0.84, 0.44, 1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}

/* Edit Panel Modal */
.edit-mode {
  background: linear-gradient(135deg, #ffffff, #f5f5f5);
  border-radius: 15px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  width: 100%;
  box-sizing: border-box;
}

.edit-mode input,
.edit-mode textarea {
  width: 100%;
  padding: 12px;
  margin-bottom: 15px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 14px;
  transition: all 0.3s ease;
  box-sizing: border-box;
  background: #ffffff;
}

.edit-mode textarea {
  min-height: 100px;
  resize: vertical;
}

.edit-mode input:focus,
.edit-mode textarea:focus {
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  outline: none;
}

.edit-mode .button-group {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.edit-mode .save-btn,
.edit-mode .cancel-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  flex: 1;
}

.edit-mode .save-btn {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
}

.edit-mode .cancel-btn {
  background: linear-gradient(135deg, #ff6b6b, #ff4757);
  color: white;
}

.edit-mode .save-btn:hover,
.edit-mode .cancel-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}



/* Animations */
@keyframes fadeInScale {
    0% { opacity: 0; transform: scale(0.95); }
    100% { opacity: 1; transform: scale(1); }
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
}

#fullscreenOverlay.fadeIn {
    animation: fadeIn 0.3s ease-out;
}

#fullscreenOverlay.fadeOut {
    animation: fadeOut 0.3s ease-out;
}

.practice-deck-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(13, 27, 42, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 4000;
      backdrop-filter: blur(10px);
    }
    .practice-deck-wrapper.active {
      opacity: 1;
      pointer-events: auto;
    }
    .practice-deck {
      position: relative;
      height: 450px;
      width: 100%;
      max-width: 700px;
      margin: auto;
      perspective: 2000px;
      overflow: visible;
      transform: translateY(-100px) translateX(50px) scale(0.98);
      transition: transform 0.5s ease;
    }

    /* Toggle Button - modified to be fixed at top right */
    #modeSwitchBtn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 5000;
      margin-bottom: 20px;
      padding: 10px 15px;
      background-color: #28a745;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    #modeSwitchBtn:hover {
      background-color: #218838;
    }

    /* Flashcard Styles */
    .practice-card {
      position: absolute;
      width: 320px;
      height: 610px;
      transform-style: preserve-3d;
      transition: transform 0.6s ease, box-shadow 0.6s ease;
      border-radius: 20px;
      background: linear-gradient(145deg, #1b263b, #415a77);
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
      cursor: pointer;
      outline: none;
    }

    .practice-card.active {
      z-index: 10;
      transform: translateZ(50px) scale(1.05);
    }

    .practice-card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px;
      text-align: center;
    }

    .practice-card-front {
      background: linear-gradient(145deg, #778da9, #e0e1dd);
      color: #0d1b2a;
      font-size: 1.5rem;
      font-family: 'Roboto Slab', serif;
    }

    .practice-card-back {
      background: linear-gradient(145deg, #415a77, #1b263b);
      color: #e0e1dd;
      transform: rotateY(180deg);
      font-size: 1.3rem;
      font-family: 'Roboto Slab', serif;
    }

    /* Controls & Close Button */
    .practice-controls {
      position: absolute;
      bottom: 20px;
      display: flex;
      gap: 20px;
    }
    .practice-controls .control-btn {
      padding: 12px 25px;
      font-size: 1rem;
      font-family: 'Open Sans', sans-serif;
      background: #778da9;
      color: #0d1b2a;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
    }

    .practice-controls .control-btn:hover {
      background: #e0e1dd;
      transform: translateY(-5px);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
    }

    .practice-controls .control-btn:focus {
      outline: 2px solid #e0e1dd;
      outline-offset: 2px;
    }

    .practice-close-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 12px 25px;
      font-size: 1rem;
      font-family: 'Open Sans', sans-serif;
      background: #ff4757;
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
    }

    .practice-close-btn:hover {
      background: #ff6b81;
      transform: translateY(-5px);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
    }


/* Input Panel */
.input-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-bottom: 30px;
    padding: 30px;
    background: #fff;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    max-width: 600px;
    width: 100%;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease-in-out;
    border: 1px solid #f1f3f5;
}

.input-panel input {
    padding: 14px 18px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    height: 50px;
    background: var(--background-color);
    color: var(--text-color);
    font-size: var(--font-size-base);
    transition: all var(--transition-duration) ease;
    box-shadow: none;
    width: 100%;
    outline: none;
    position: relative;
    z-index: 1;
    letter-spacing: 0.2px;
}

.input-panel input::placeholder {
    color: #9aa5b1;
    transition: all var(--transition-duration) ease;
}

.input-panel input:focus {
    border-color: var(--primary-color);
    background: #fff;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
}

.input-panel input:focus::placeholder {
    opacity: 0.7;
    transform: translateX(5px);
}

.input-panel input[id="answer"] {
    height: 150px;
    resize: vertical;
    min-height: 150px;
    max-height: 300px;
    font-family: inherit;
    line-height: 1.5;
}

.input-panel label {
    color: #495057;
    margin-bottom: 6px;
    font-weight: var(--font-weight-medium);
    font-size: 14px;
    letter-spacing: 0.2px;
    display: block;
    position: relative;
    z-index: 1;
    transition: all var(--transition-duration) ease;
}

.input-panel .form-group {
    position: relative;
    margin-bottom: 16px;
}

.input-panel .form-group:hover label {
    color: var(--text-color);
}

.input-panel .helper-text {
    font-size: 13px;
    color: #6c757d;
    margin-top: 6px;
    font-style: italic;
}

.input-panel .error input {
    border-color: var(--danger-color);
    background: #fff;
}

.input-panel .error-message {
    color: var(--danger-color);
    font-size: 13px;
    margin-top: 6px;
    display: block;
}

.input-panel .success input {
    border-color: var(--success-color);
    background: #fff;
}

.input-panel button {
    background: var(--primary-color);
    border: none;
    border-radius: var(--border-radius);
    color: white;
    padding: 14px 24px;
    font-size: var(--font-size-base);
    font-weight: var(--font-weight-medium);
    cursor: pointer;
    transition: all var(--transition-duration) ease;
    position: relative;
    overflow: hidden;
    letter-spacing: 0.2px;
    box-shadow: var(--box-shadow);
    z-index: 1;
    align-self: flex-end;
    margin-top: 10px;
}

.input-panel button:hover {
    background: var(--primary-color-dark);
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(0, 123, 255, 0.15);
}

.input-panel button:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.1);
}

.input-panel .tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(33, 37, 41, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 13px;
    opacity: 0;
    visibility: hidden;
    transition: all var(--transition-duration) ease;
    width: max-content;
    max-width: 200px;
    z-index: 10;
    pointer-events: none;
}

.input-panel .tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: rgba(33, 37, 41, 0.9);
}

.input-panel *:hover > .tooltip {
    opacity: 1;
    visibility: visible;
    bottom: calc(100% + 10px);
}

.input-panel input:focus-visible,
.input-panel button:focus-visible {
    outline: none;
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
}

.input-panel.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: var(--primary-color);
    animation: loading 1.5s infinite;
    z-index: 9;
}

@keyframes loading {
    0% { left: -100%; }
    100% { left: 100%; }
}

.button-panel {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  margin: 0 auto;
  background-color: #f5f5f7;
  padding: 24px;
  border-radius: 16px;
  box-shadow: 0 12px 28px rgba(0, 0, 0, 0.12), 
              0 0 1px rgba(0, 0, 0, 0.1);
  position: relative;
  max-width: 600px;
  width: 100%;
  overflow: hidden;
}

.button-panel button {
  width: 100%;
  height: 100px;
  padding: 0 12px;
  background: linear-gradient(135deg, #e3f2fd, #bbdefb); /* Light bluish tint for regular buttons */
  border: none;
  border-radius: 0;
  color: #5b7b70de;
  content: flex;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  text-align: center;
  position: relative;
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1),
              0 3px 5px rgba(0, 0, 0, 0.05),
              inset 0 -2px 5px rgba(0, 0, 0, 0.05);
  transition: all 0.3s ease;
  overflow: hidden;
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  letter-spacing: 0.2px;
  outline: #0069d9;
  outline-offset: 1px;
  outline-width: 2px;
  clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

/* Special styling for "Add Card" button */
.button-panel button:nth-child(3) {
  background: linear-gradient(135deg, #ffd700, #daa520); /* Golden gradient */
  color: #4a4a4a;
  box-shadow: 0 10px 20px rgba(218, 165, 32, 0.2),
              0 6px 10px rgba(218, 165, 32, 0.1),
              inset 0 -2px 5px rgba(0, 0, 0, 0.1);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* Active state for buttons */
.button-panel button:active {
  opacity: 0.9;
}

/* Create a better honeycomb effect with positioning tricks */
@media (min-width: 768px) {
  .button-panel {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    grid-template-rows: repeat(4, auto);
    gap: 8px;
    padding: 30px 20px;
    max-width: 500px;
  }
  
  /* Position for "Add Note" button - top left */
  .button-panel button:nth-child(1) {
    grid-column: 1 / span 2;
    grid-row: 1;
    width: 140px;
    height: 90px;
    justify-self: center;
    transform: translateY(70px) translateX(30px); /* Added Y translation to move button down */
  }
  
  /* Position for "Shuffle Cards" button - top center */
  .button-panel button:nth-child(2) {
    grid-column: 3 / span 2;
    grid-row: 1;
    width: 140px;
    height: 90px;
    justify-self: center;
    transform: translateY(25px);
  }
  
  /* Position for "Add Card" button - center (black dot position) */
  .button-panel button:nth-child(3) {
    grid-column: 3 / span 2;
    grid-row: 2 / span 1;
    width: 140px;
    height: 90px;
    justify-self: center;
    z-index: 1;
    margin-top: -15px;
    margin-bottom: -15px;
    transform: translateY(25px);
  }
  
  /* Position for "Make Connexions" button - bottom left */
  .button-panel button:nth-child(4) {
    grid-column: 1 / span 2;
    grid-row: 2 / span 1;
    width: 140px;
    height: 90px;
    justify-self: center;
    transform: translateY(70px) translateX(30px); /* Added Y translation to move button down */
  }
  
  /* Position for "Let's Practice" button - top right */
  .button-panel button:nth-child(5) {
    grid-column: 5 / span 2;
    grid-row: 1;
    width: 140px;
    height: 90px;
    justify-self: center;
    transform: translateY(70px) translateX(-30px);; /* Added Y translation to move button down */
  }
  
  /* Position for "Import Cards" button - bottom right */
  .button-panel button:nth-child(6) {
    grid-column: 5 / span 2;
    grid-row: 2 / span 1;
    width: 140px;
    height: 90px;
    justify-self: center;
    transform: translateY(70px) translateX(-30px); /* Added Y translation to move button down */
  }
  
  /* Position for "Export Cards" button - bottom center */
  .button-panel button:nth-child(7) {
    grid-column: 3 / span 2;
    grid-row: 3;
    width: 140px;
    height: 90px;
    justify-self: center;
    margin-top: -15px;
    transform: translateY(10px);
  }
  
  /* Position for category section */
  .button-panel .category-section {
    grid-column: 1 / span 6;
    grid-row: 4;
    width: 100%;
    margin-top: 20px;
    transform: translateY(10px) translateX(-10px);
  }
}

/* On smaller screens, simplify to 2-column layout */
@media (max-width: 767px) {
  .button-panel {
    grid-template-columns: repeat(2, 1fr);
    padding: 20px 20px 80px 20px;
  }
  
  .button-panel button {
    margin-bottom: -30px;
  }
  
  .button-panel button:nth-child(even) {
    transform: translateY(70%);
  }
  
  .button-panel button:nth-child(even):hover {
    transform: translateY(70%) scale(1.05);
  }
}

/* On very small screens, switch to 3x3 grid */
@media (max-width: 600px) {
  .button-panel {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    padding: 15px;
    gap: 10px;
  }
  
  .button-panel button {
    height: 80px; /* Adjust height for a more square look */
    clip-path: none; /* Remove hexagonal clip-path */
    border-radius: 8px; /* Add standard border-radius */
    margin-bottom: 0;
    transform: none !important;
  }
  
  .button-panel button:hover {
    transform: scale(1.05) !important;
  }
}

.button-panel button {
  width: 100%;
  height: 100px;
  padding: 0 12px;
  background: linear-gradient(135deg, #e3f2fd, #bbdefb); /* Light bluish tint for regular buttons */
  border: none;
  border-radius: 0;
  color: #5b7b70de;
  content: flex;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  text-align: center;
  position: relative;
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1),
              0 3px 5px rgba(0, 0, 0, 0.05),
              inset 0 -2px 5px rgba(0, 0, 0, 0.05);
  transition: all 0.3s ease;
  overflow: hidden;
  font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  letter-spacing: 0.2px;
  outline: #0069d9;
  outline-offset: 1px;
  outline-width: 2px;
  clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

/* Special styling for "Add Card" button */
.button-panel button:nth-child(3) {
  background: linear-gradient(135deg, #ffd700, #daa520); /* Golden gradient */
  color: #4a4a4a;
  box-shadow: 0 10px 20px rgba(218, 165, 32, 0.2),
              0 6px 10px rgba(218, 165, 32, 0.1),
              inset 0 -2px 5px rgba(0, 0, 0, 0.1);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* Active state for buttons */
.button-panel button:active {
  opacity: 0.9;
}

/* The category section is now inside the button panel */
.category-section {
  margin-top: 40px;
  width: 93%;
  background-color: #ffffff;
  border-radius: 12px;
  padding: 10px;
  transform: translatey(25%);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  grid-column: 1 / -1; /* Span all columns */
}

.category-section h3 {
  margin-top: 0;
  margin-bottom: 12px;
  font-size: 18px;
  color: #4A4E57;
  font-weight: 500;
}

.category-section select {
  width: 100%;
  height: 50px;
  padding: 0 16px;
  background-color: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 10px;
  color: #947A6D;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23947A6D' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 16px center;
  background-size: 12px;
  display: block;
}

/* Media query for responsiveness */
@media (max-width: 480px) {
  .button-panel {
    padding: 20px;
    gap: 10px;
  }
  
  .button-panel button,
  .button-panel select {
    height: 54px;
    font-size: 15px;
  }
}

/* Panel Wrapper */
.panel-wrapper {
    display: flex;
    gap: 24px;
    width: 100%;
    max-width: 1200px;
    margin: 30px auto;
    padding: 30px;
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.1)),
                linear-gradient(to bottom, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.05));
    backdrop-filter: blur(8px);
    border-radius: 16px;
    box-shadow: 
                
            
                inset 0 -2px 8px rgba(183, 194, 202, 0.403),
               
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
}

.panel-wrapper::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(145deg, rgba(214, 216, 163, 0.4), rgba(214, 216, 163, 0.2));
    opacity: 0.7;
    z-index: -1;
    border-radius: inherit;
    box-shadow: inset 12px 0 20px -5px rgba(0, 0, 0, 0.15),
                inset -12px 0 20px -5px rgba(0, 0, 0, 0.15);
}

.panel-wrapper::after {
    content: '';
    position: absolute;
    top: 1px;
    left: 1px;
    right: 1px;
    bottom: 1px;
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), transparent);
    border-radius: inherit;
    z-index: -1;
}

.input-panel, .button-panel {
    flex: 1;
    margin-bottom: 0;
    min-width: 300px;
    max-width: 500px;
    height: auto;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
    .panel-wrapper {
        flex-direction: column;
        padding: 20px;
        margin: 15px;
    }
    
    .input-panel, .button-panel {
        width: 100%;
        max-width: 100%;
    }

    body {
        padding: 15px;
    }

    .controls {
        flex-direction: column;
        align-items: stretch;
    }

    .controls input[type="text"],
    .controls select,
    .controls button {
        width: 100%;
        margin-bottom: 10px;
    }

    .flashcard {
        flex: 1 0 100%;
    }

    #subcardsModal .modal-content,
    #noteModal .modal-content {
        max-width: 95%;
    }

    .practice-card {
        width: 90vw;
        height: auto;
        min-height: 300px;
    }

    .practice-controls {
        flex-direction: column;
        gap: 10px;
    }

    .practice-controls .control-btn {
        width: 100%;
    }
}

@media (max-width: 480px) {
    .input-panel {
        padding: 15px;
    }

    .controls {
        padding: 20px;
    }
    
    .flashcard {
        min-width: 280px;
    }
    
    header h1 {
        font-size: 2.2em;
    } 
}

    /* Connexion Mode Styles */
    #connexionCanvas {
      overflow: auto;
  position: fixed;     /* Changed from relative to fixed */
  top: 0;             /* Added */
  left: 0;            /* Added */
  width: 100vw;       /* Changed from 100% to 100vw */
  height: 100vh;      /* Changed from 100vh to ensure full viewport height */
  background: #828a5e;
  overflow: auto;
  display: none;
  z-index: 1000;      /* Added to ensure it stays on top */
}

.connexion-card {
  position: absolute;
  width: 200px;
  height: 250px;
  background: linear-gradient(135deg, #ffffff, #f5f5f5);
  border: 1px solid #666;
  border-radius: 8px;
  padding: 15px;
  cursor: move;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  touch-action: none;
  user-select: none;
  z-index: 1;
}
.connexion-card.can-connect {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
  transform: scale(1.05);
}
.connexion-card.selected {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
  transform: scale(1.05);
  z-index: 2;
}

/* Add active state for touch feedback */
.connexion-card:active {
  transform: scale(0.98);
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
}

/* Ensure text remains readable */
.connexion-card h4,
.connexion-card p {
  pointer-events: none;
}
    .connexion-card:hover {
      transform: scale(1.02);
    }
    .connexion-card.can-connect {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
  transform: scale(1.05);
}

.connection-panel {
  position: absolute;
  width: 450px;
  min-height: 200px;
  height: auto;
  max-height: 80vh;
  background: linear-gradient(135deg, #1a0033, #6902ef);
  border: none;
  border-radius: 20px;
  padding: 20px;
  box-shadow: 0 10px 30px rgba(105, 2, 239, 0.6), 
              inset 0 0 100px rgba(255, 255, 255, 0.1);
  cursor: move;
  touch-action: none; /* Prevents default touch actions */
  -webkit-user-select: none; /* Prevents text selection */
  user-select: none;
  z-index: 1000;
}

/* Add touch-friendly button sizes */
.connection-buttons button {
  min-height: 44px; /* Minimum touch target size */
  min-width: 44px;
  padding: 12px 25px;
  margin: 8px;
  font-size: 16px;
}

/* Add active states for touch feedback */
.connection-buttons button:active {
  transform: scale(0.95);
  background: linear-gradient(45deg, #5701c3, #9340e0);
}
  
  .connection-panel:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 40px rgba(105, 2, 239, 0.8),
                inset 0 0 120px rgba(255, 255, 255, 0.15);
  }
  
  @keyframes glow {
    from {
      box-shadow: 0 10px 30px rgba(105, 2, 239, 0.6),
                  inset 0 0 100px rgba(255, 255, 255, 0.1);
    }
    to {
      box-shadow: 0 10px 30px rgba(105, 2, 239, 0.8),
                  inset 0 0 100px rgba(255, 255, 255, 0.2);
    }
  }
  
.connection-card {
      background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 15px;
    flex: 1 0 calc(50% - 15px);
    min-width: 180px;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transform: perspective(1000px) rotateX(5deg);
  }

    
  .card:hover {
    transform: perspective(1000px) rotateX(0deg) translateY(-5px);
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  .connection-description {
    margin: 20px 0;
    background: rgba(218, 206, 206, 0.408);
    padding: 15px;
    border-radius: 10px;
    border-left: 4px solid #9c4dff;
    font-size: 16px;
    line-height: 1.6;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  }
  
  .connection-buttons {
    margin-top: 20px;
    display: flex;
    gap: 15px;
  }
  
  .button {
    background: linear-gradient(45deg, #6902ef, #af5fff);
    color: white;
    border: none;
    border-radius: 30px;
    padding: 12px 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(105, 2, 239, 0.4);
    position: relative;
    overflow: hidden;
  }
  
  .button:hover {
    background: linear-gradient(45deg, #5b01d3, #9340e0);
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(105, 2, 239, 0.6);
  }
  
  .button::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(30deg);
    transition: all 0.3s ease;
    opacity: 0;
  }
  
  .button:hover::after {
    opacity: 1;
    transform: rotate(30deg) translate(10%, -10%);
  }
  
  /* Custom scrollbar */
  .connection-panel::-webkit-scrollbar {
    width: 8px;
  }
  
  .connection-panel::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
  }
  
  .connection-panel::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #6902ef, #af5fff);
    border-radius: 10px;
  }
  
  .connection-panel::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #5b01d3, #9340e0);
  }

    .connection-buttons button  {
    background: linear-gradient(45deg, #6902ef, #af5fff);
    color: white;
    border: none;
    border-radius: 30px;
    padding: 12px 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(105, 2, 239, 0.4);
    position: relative;
    overflow: hidden;
  }

    .connexion-card h4,
.connexion-card p {
  color: #033b4e;  /* Added to ensure headers and paragraphs are black */
}

.connection-panel {
  /* ... existing styles ... */
  color: #ffffff;  /* Added this line */
}

.connection-panel h4,
.connection-panel p {
  color: #ffffff;  /* Added to ensure headers and paragraphs are black */
}

.connection-description {
  margin-top: 10px;
  font-size: 14px;
  color: #333;  /* Already defined but ensuring it's visible */
}
    .connection-buttons .edit-connection after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(30deg);
    transition: all 0.3s ease;
    opacity: 0;
  }


    .connection-buttons .edit-connection:hover {
      background: linear-gradient(135deg, #7f9cf5, #805ad5);
    }

    .connection-buttons .view-connection {
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      color: #fff;
    }

    .connection-buttons .view-connection:hover {
      background: linear-gradient(135deg, #55e7a0, #4cd786);
    }

    .connection-buttons .remove-connection {
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: #fff;
    }

    .connection-buttons .remove-connection:hover {
      background: linear-gradient(135deg, #ff8787, #ff6565);
    }

    /* Flip functionality for connexion cards */
    .connexion-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    .connexion-card.flipped .connexion-card-inner {
      transform: rotateY(180deg);
    }

    .connexion-card-front, .connexion-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      padding: 15px;
      box-sizing: border-box;
      border-radius: 8px;
    }

    .connexion-card-front {
      background: linear-gradient(135deg, #ffffff, #f5f5f5);
    }

    .connexion-card-back {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      transform: rotateY(180deg);
      color: #333;
    }
.connection-cards {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}
.connection-card {
  flex: 1 1 200px;
}
 
/* Define reusable variables */
/* Define reusable variables */
/* Define reusable variables */
:root {
  --bg-start: #a0e948;
  --bg-end: #ecf2dd;
  --node-fill: rgba(221, 254, 88, 0.738);
  --node-stroke: #4a90e2;
  --node-hover-fill: #c3d1dd;
  --node-hover-stroke: #2779bd;
  --text-color: #2d3748;
  --text-category-color: #805ad5;
  --line-stroke-width: 2px;
  --line-dasharray: 6;
  --drop-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  --drop-shadow-hover: 0 6px 12px rgba(0, 0, 0, 0.4);
  --transition-duration: 0.3s;
  --transition-timing: ease;
  --node-border-radius: 5px;
}

/* Mind Map Container with animated gradient and overlay texture */
#mindMapView {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
  background-size: 300% 300%;
  animation: gradientShift 20s ease infinite;
}

/* Additional background texture for depth */
#mindMapView::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle at center, rgba(255,255,255,0.05), transparent);
  animation: pulseBg 12s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

/* Animated background gradient shift */
@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* Pulse animation for the background overlay */


/* SVG Container stays above the background overlay */
#mindMapView svg {
  width: 100%;
  height: 100%;
  position: relative;
  z-index: 1;
}

/* Connection Lines with glowing effect and animated dash offset */
#mindMapView line {
  stroke: var(--node-stroke);
  stroke-width: var(--line-stroke-width);
  stroke-linecap: round;
  stroke-dasharray: var(--line-dasharray);
  filter: drop-shadow(0 0 8px rgba(17, 1, 1, 0.6));
  animation: flowLine 30s linear infinite;
}

/* Nodes reimagined with enhanced shadow, slight rotation on hover, and increased scale */
#mindMapView rect {
  fill: var(--node-fill);
  stroke: var(--node-stroke);
  stroke-width: var(--line-stroke-width);
  rx: calc(var(--node-border-radius)* 1);
  ry: calc(var(--node-border-radius) * 1.5);
  filter: drop-shadow(var(--drop-shadow)) drop-shadow(0 0 8px rgba(255, 255, 255, 0.2));
  transition: transform var(--transition-duration) var(--transition-timing),
              fill var(--transition-duration) var(--transition-timing),
              filter var(--transition-duration) var(--transition-timing);
}

/* Enhanced Node Hover Effects */
#mindMapView rect:hover {
  fill: var(--node-hover-fill);
  stroke: var(--node-hover-stroke);
  transform: scale(1.1) rotate(1deg);
  filter: drop-shadow(var(--drop-shadow-hover)) drop-shadow(0 0 12px rgba(255, 255, 255, 0.3));
}

/* Text Styling with pronounced shadows for clarity */
#mindMapView text {
  font-family: 'Segoe UI', system-ui, sans-serif;
  fill: var(--text-color);
  font-size: 16px;
  font-weight: 500;
  pointer-events: none;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
}
#mindMapView text {
  white-space: normal; /* Allow wrapping */
  overflow-wrap: break-word;
  padding: 5px; /* Some padding inside the node, if applicable */
}

/* Category Text Styling with letter spacing and shadow */
#mindMapView text.category {
  fill: var(--text-category-color);
  font-size: 14px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
}

/* Connection Labels with increased font size and shadow */
#mindMapView text.connection-label {
  fill: #ffffff;
  font-size: 14px;
  font-weight: 500;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}

/* Animation for connection lines */
@keyframes flowLine {
  from {
    stroke-dashoffset: 1000;
  }
  to {
    stroke-dashoffset: 0;
  }
}

/* Responsive Adjustments for smaller screens */
@media (max-width: 768px) {
  #mindMapView text {
    font-size: 14px;
  }
  
  #mindMapView text.category {
    font-size: 12px;
  }
  
  #mindMapView text.connection-label {
    font-size: 12px;
  }
}
.mind-map-button  {
    background: linear-gradient(45deg, #6902ef, #af5fff);
    color: white;
    border: none;
    border-radius: 30px;
    padding: 12px 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(105, 2, 239, 0.4);
    position: relative;
    overflow: hidden;
  }

  .fullscreen-mode {
  position: fixed !important;
  top: 0;
  left: 0;
  width: 100vw !important;
  height: 100vh !important;
  background: linear-gradient(125deg, #0a0c1f, #1a1f35, #0f2242);
  background-size: 400% 400%;
  animation: gradientShift 15s ease infinite;
  z-index: 10000;
  padding: 3rem;
  display: flex !important;
  flex-wrap: wrap;
  justify-content: center;
  align-content: flex-start;
  gap: 2.5rem;
  overflow-y: auto;
  margin: 0 !important;
  box-sizing: border-box;
  box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.4);
}

.fullscreen-mode .flashcard {
  position: relative !important;
  width: calc(25% - 2rem) !important; /* 4 cards per row with gap */
  min-width: 250px !important;
  height: 300px !important;
  margin: 0 !important;
  transform: none !important;
  transition: all 0.3s ease;
  flex: 1 1 250px;
  max-width: 350px;
}

.fullscreen-mode .flashcard-inner {
  height: 100%;
  width: 100%;
}

.exit-fullscreen-btn {
  position: fixed;
  top: 25px;
  right: 25px;
  background: rgba(20, 30, 60, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.95);
  padding: 14px 32px;
  border-radius: 40px;
  cursor: pointer;
  z-index: 10001;
  backdrop-filter: blur(15px);
  font-size: 16px;
  font-weight: 500;
  letter-spacing: 0.8px;
  transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2), 0 3px 10px rgba(0, 0, 0, 0.1);
  text-transform: uppercase;
}


.fullscreen-wrapper {
  display: flex;
  justify-content: center;
  margin-top: 20px;
  margin-bottom: 20px;
}

.fullscreen-button {
  background: linear-gradient(45deg, #6902ef, #af5fff);
  color: white;
  border: none;
  border-radius: 30px;
  padding: 14px 32px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
  text-transform: uppercase;
  letter-spacing: 0.8px;
}

.fullscreen-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 30px rgba(105, 2, 239, 0.3);
  background: linear-gradient(45deg, #5b01d3, #9340e0);
}

.fullscreen-button:active {
  transform: translateY(1px);
  box-shadow: 0 5px 15px rgba(105, 2, 239, 0.2);
}
/* Add these styles to your existing CSS */
.fullscreen-controls {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  background: rgba(20, 30, 60, 0.8);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  gap: 15px;
  z-index: 10001;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.fs-control-group {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
}

.fs-btn {
  background: rgba(255, 255, 255, 0.15);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

/* Fullscreen dropdown menu */
.fs-dropdown {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 10002;
}

.fs-dropdown-btn {
  background: linear-gradient(135deg, #6902ef, #af5fff);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 20px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.fs-dropdown-btn:hover {
  background: linear-gradient(135deg, #5b01d3, #9340e0);
}

.fs-dropdown-content {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 10px;
  background: rgba(20, 30, 60, 0.95);
  backdrop-filter: blur(10px);
  min-width: 250px;
  border-radius: 12px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
  z-index: 10003;
  overflow: hidden;
  animation: fadeInScale 0.3s ease-out;
}

.fs-dropdown-content.show {
  display: block;
}

.fs-dropdown-item {
  padding: 12px 20px;
  color: white;
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.fs-dropdown-item:last-child {
  border-bottom: none;
}

.fs-dropdown-item:hover {
  background: rgba(255, 255, 255, 0.1);
}

.fs-dropdown-item i {
  font-size: 18px;
  width: 24px;
  text-align: center;
}

/* Category panels for animation */
.category-panels-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  z-index: 10000;
}

.category-panel {
  position: absolute;
  background: rgba(20, 30, 60, 0.7);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 20px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
  overflow: auto;
}

.category-panel-header {
  color: white;
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 20px;
  text-align: center;
  text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  border-bottom: 2px solid rgba(255, 255, 255, 0.2);
  padding-bottom: 10px;
}

.category-panel .flashcard {
  transform: scale(0);
  opacity: 0;
  transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
  transition-delay: calc(var(--card-index) * 0.1s);
}

.category-panel.active .flashcard {
  transform: scale(1);
  opacity: 1;
}

/* Back button for category view */
.category-view-back {
  position: fixed;
  top: 20px;
  left: 20px;
  background: linear-gradient(135deg, #ff6b6b, #ff4757);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 20px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  z-index: 10004;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  display: none;
}

.category-view-back:hover {
  background: linear-gradient(135deg, #ff8787, #ff6565);
}

/* Mobile Controls */
#mobile-controls-trigger {
  display: none; /* Hidden by default */
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 60px;
  height: 60px;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 50%;
  font-size: 24px;
  line-height: 60px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  z-index: 1001;
}

@media (max-width: 767px) {
  /* Hide the button panel in the normal flow on mobile, and show the trigger */
  .panel-wrapper .button-panel-wrapper {
    display: none;
  }
  #mobile-controls-trigger {
    display: block;
  }

  /* When the floating button is clicked, show the wrapper as a fixed-position panel */
  .button-panel-wrapper.mobile-controls-active {
    display: block;
    position: fixed;
    bottom: 90px;
    right: 20px;
    width: auto;
    z-index: 1000;
  }

  /* Style the button panel grid *inside* the active floating panel */
  .button-panel-wrapper.mobile-controls-active .button-panel {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(8px);
    border-radius: 16px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    /* Override other styles from wider media queries */
    width: auto;
    flex-direction: unset;
  }

  /* Style the buttons *inside* the active floating panel */
  .button-panel-wrapper.mobile-controls-active .button-panel button {
    width: 70px;
    height: 70px;
    clip-path: none;
    border-radius: 12px;
    font-size: 10px;
    line-height: 1.2;
    padding: 4px;
    /* Override styles from wider media queries */
    margin: 0;
    transform: none !important;
  }

  /* Handle the category section inside the popup */
  .button-panel-wrapper.mobile-controls-active .category-section {
      grid-column: 1 / -1; /* Span all columns */
      margin-top: 5px;
      transform: none;
      padding: 0;
      width: 100%;
      background: transparent;
      box-shadow: none;
  }
}
  </style>
</head>
<body>
  <button id="mobile-controls-trigger">&#9776;</button> <!-- Hamburger Icon -->

  <header>
    <h1>ABS Flashcards</h1>
  </header>
  
  <div class="panel-wrapper">
    <div class="input-panel">
      <input type="text" id="category" placeholder="Enter category" list="categoryList">
      <datalist id="categoryList"></datalist>
      <input type="text" id="question" placeholder="Enter question / title">
      <input type="text" id="answer" placeholder="Enter answer or note content (LaTeX supported)">
      <button onclick="addNewCard()">Add Card</button>
      <option value="all">Made for desktop only</option>
    </div>
    
    <div class="button-panel-wrapper">
        <div class="button-panel">
        <button onclick="addNewNote()">Add Note</button>
        
        <button onclick="shuffleCards()">Shuffle Cards</button>
        
        <button onclick="addNewCard()">Add Card</button>
        
        <button onclick="enterConnexionMode()">Make Connexions</button>
        
        <button onclick="startPracticeMode()">Let's Practice</button>
        
        <button id="importBtn" onclick="document.getElementById('importFile').click()">Import Cards</button>
        
        <button id="exportBtn" onclick="exportCards()">Export Cards</button>
        
        <input type="file" id="importFile" accept=".json" onchange="importCards(event)" style="display: none;">
        <div class="category-section">
            <h3>Filter by Category</h3>
            <select id="filterCategory" onchange="renderCards()">
            <option value="all">Show All Categories</option>
            </select>
        </div>
        </div>
    </div>
  </div>
<div class="fullscreen-wrapper">
  <button id="fullscreenBtn" class="fullscreen-button">Fullscreen View</button>
</div>

  <div class="flashcard-container" id="cardContainer"></div>
  <div id="connexionCanvas"></div>
  
  <!-- Modal for Subcards (initially hidden) -->
  <div id="subcardsModal"></div>
  <!-- Modal for Expanded Note (initially hidden) -->
  <div id="noteModal"></div>
  
  <!-- Side Panel Toggle Button & Panel -->
       
           <div class="practice-deck-wrapper" id="practiceDeck">
    <button class="practice-close-btn" onclick="exitPracticeMode()">Close</button>
    <div class="practice-deck" id="practiceDeckContainer"></div>
    <div class="practice-controls">
      <button class="control-btn" onclick="showPrevCard()">Previous</button>
      <button class="control-btn" onclick="showNextCard()">Next</button>
    </div>
  </div>
 <script> 
/***********************
 * Default Cards Data  *
 ***********************/
const cardsData = [
  {
    category: "Quantum Mechanics",
    question: "Time-independent Schrödinger Equation",
    answer: "$$ -\\frac{\\hbar^2}{2m}\\nabla^2\\psi(\\mathbf{r}) + V(\\mathbf{r})\\psi(\\mathbf{r}) = E\\psi(\\mathbf{r}) $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Time-dependent Schrödinger Equation",
    answer: "$$ i\\hbar\\,\\frac{\\partial}{\\partial t}\\psi(\\mathbf{r},t) = -\\frac{\\hbar^2}{2m}\\nabla^2\\psi(\\mathbf{r},t) + V(\\mathbf{r})\\psi(\\mathbf{r},t) $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Momentum Operator",
    answer: "$$ \\hat{p} = -i\\hbar\\,\\frac{\\partial}{\\partial x} $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Position Operator",
    answer: "$$ \\hat{x} = x $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Probability Density",
    answer: "$$ \\rho(\\mathbf{r},t) = |\\psi(\\mathbf{r},t)|^2 $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Current Density",
    answer: "$$ \\mathbf{j}(\\mathbf{r},t) = \\frac{\\hbar}{2mi}\\left(\\psi^*\\nabla\\psi - \\psi\\nabla\\psi^*\\right) $$",
    type: "card"
  }
];

let currentCards = [];
let connections = [];
let currentFilteredCards = [];
let isSelectMode = false; // Tracks if we're in selection mode
let selectedCards = new Set(); // Stores the IDs of selected cards

// Track segregation state
let isSegregated = false;
let originalPositions = {};
let globalEventHandlersInitialized = false;
let activeConnectionCreation = false;

// Store active drag state
let activeDrag = {
  element: null,
  isDragging: false,
  startX: 0,
  startY: 0
};

// Union-Find class for clustering
class UnionFind {
  constructor(elements) {
    this.parent = {};
    this.rank = {};
    elements.forEach(el => {
      this.parent[el] = el;
      this.rank[el] = 0;
    });
  }

  find(el) {
    if (this.parent[el] !== el) {
      this.parent[el] = this.find(this.parent[el]);
    }
    return this.parent[el];
  }

  union(el1, el2) {
    const root1 = this.find(el1);
    const root2 = this.find(el2);
    if (root1 === root2) return;
    if (this.rank[root1] < this.rank[root2]) {
      this.parent[root1] = root2;
    } else {
      this.parent[root2] = root1;
      if (this.rank[root1] === this.rank[root2]) {
        this.rank[root1]++;
      }
    }
  }
}

/******************************
 * Rendering & Storage Logic  *
 ******************************/
function renderCards() {
  const container = document.getElementById('cardContainer');
  container.innerHTML = '';
  const filterValue = document.getElementById('filterCategory').value;
  const filteredCards = filterValue === 'all'
    ? currentCards
    : currentCards.filter(card => card.category === filterValue);
  filteredCards.forEach(card => {
    container.appendChild(createCard(card));
  });
  updateCategoryLists();
}

function updateCategoryLists() {
  const categorySet = new Set();
  currentCards.forEach(card => {
    if (card.category) categorySet.add(card.category);
  });
  const dataList = document.getElementById('categoryList');
  dataList.innerHTML = '';
  categorySet.forEach(cat => {
    const option = document.createElement('option');
    option.value = cat;
    dataList.appendChild(option);
  });
  const filterSelect = document.getElementById('filterCategory');
  const currentSelection = filterSelect.value;
  filterSelect.innerHTML = '<option value="all">Show All Categories</option>';
  categorySet.forEach(cat => {
    const option = document.createElement('option');
    option.value = cat;
    option.textContent = cat;
    filterSelect.appendChild(option);
  });
  filterSelect.value = currentSelection;
}

function loadCards() {
  const saved = localStorage.getItem('flashcards');
  if (saved) {
    currentCards = JSON.parse(saved);
  } else {
    currentCards = cardsData.map(card => ({
      ...card,
      id: `card-${Date.now()}-${Math.random()}`
    }));
  }
  renderCards();
}

function saveCards() {
  localStorage.setItem('flashcards', JSON.stringify(currentCards));
}

function loadConnections() {
  const saved = localStorage.getItem('connections');
  if (saved) {
    connections = JSON.parse(saved);
    connections = connections.map(conn => {
      // If 'cards' exists, keep the connection as is
      if (conn.cards) {
        return conn;
      } 
      // Migrate legacy format with 'card1' and 'card2'
      else if (conn.card1 && conn.card2) {
        return {
          id: conn.id,
          cards: [conn.card1, conn.card2],
          description: conn.description,
          tag: conn.tag,
          color: conn.color
        };
      } 
      // Log and discard invalid connections
      else {
        console.warn('Invalid connection found and will be removed:', conn);
        return null;
      }
    }).filter(Boolean); // Remove null entries
  } else {
    connections = [];
  }
}

function saveConnections() {
  localStorage.setItem('connections', JSON.stringify(connections));
}

/******************************
 * Modal Functions for Subcards *
 ******************************/
function openSubcardsModal(parentCard) {
  // Check if we're in fullscreen mode
  const container = document.querySelector('.flashcard-container');
  const isFullscreen = container.classList.contains('fullscreen-mode');
  
  if (isFullscreen) {
    // In fullscreen mode, show subcards in a panel
    openSubcardsPanel(parentCard);
  } else {
    // In normal mode, show subcards in a modal
    const modal = document.getElementById('subcardsModal');
    modal.innerHTML = '';
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    const closeBtn = document.createElement('button');
    closeBtn.className = 'close-modal';
    closeBtn.textContent = '×';
    closeBtn.onclick = closeSubcardsModal;
    modalContent.appendChild(closeBtn);
    const modalTitle = document.createElement('h2');
    modalTitle.textContent = 'Subcards';
    modalTitle.style.textAlign = 'center';
    modalContent.appendChild(modalTitle);
    const modalSubcardsContainer = document.createElement('div');
    modalSubcardsContainer.className = 'modal-subcards-container';
    if (parentCard.subcards && parentCard.subcards.length > 0) {
      parentCard.subcards.forEach(subcard => {
        modalSubcardsContainer.appendChild(createSubcardForModal(subcard));
      });
    } else {
      const noSubcardsMsg = document.createElement('p');
      noSubcardsMsg.textContent = 'No subcards available.';
      modalSubcardsContainer.appendChild(noSubcardsMsg);
    }
    modalContent.appendChild(modalSubcardsContainer);
    modal.appendChild(modalContent);
    modal.style.display = 'flex';
  }
}

// Function to open subcards in a panel (for fullscreen mode)
function openSubcardsPanel(parentCard) {
  const container = document.querySelector('.flashcard-container');
  
  // Create or get subcards panel container
  let subcardsPanel = container.querySelector('.subcards-panel-container');
  if (!subcardsPanel) {
    subcardsPanel = document.createElement('div');
    subcardsPanel.className = 'subcards-panel-container';
    container.appendChild(subcardsPanel);
  }
  
  // Clear previous content
  subcardsPanel.innerHTML = '';
  
  // Create panel header with title and back button
  const panelHeader = document.createElement('div');
  panelHeader.className = 'subcards-panel-header';
  
  const backBtn = document.createElement('button');
   backBtn.className = 'subcards-panel-back';
  backBtn.textContent = 'Exit';
  backBtn.onclick = exitSubcardsPanel;
  
  const panelTitle = document.createElement('h2');
  panelTitle.textContent = `Subcards: ${parentCard.question}`;
  
  panelHeader.appendChild(backBtn);
  panelHeader.appendChild(panelTitle);
  subcardsPanel.appendChild(panelHeader);
  
  // Add a subtle glass effect overlay
  const glassOverlay = document.createElement('div');
  glassOverlay.className = 'glass-overlay';
  subcardsPanel.appendChild(glassOverlay);
  
  // Create subcards container
  const subcardsContainer = document.createElement('div');
  subcardsContainer.className = 'subcards-panel-cards';
  
  if (parentCard.subcards && parentCard.subcards.length > 0) {
    parentCard.subcards.forEach((subcard, idx) => {
      const subcardElement = createSubcardForPanel(subcard);
      subcardElement.style.opacity = '0';
      subcardElement.style.transform = 'scale(0.8)';
      subcardsContainer.appendChild(subcardElement);
      
      // Animate subcards with staggered delay
      setTimeout(() => {
        subcardElement.style.opacity = '1';
        subcardElement.style.transform = 'scale(1)';
      }, 50 + idx * 50);
    });
  } else {
    const noSubcardsMsg = document.createElement('p');
    noSubcardsMsg.textContent = 'No subcards available.';
    noSubcardsMsg.style.textAlign = 'center';
    noSubcardsMsg.style.padding = '20px';
    noSubcardsMsg.style.color = '#fff';
    subcardsContainer.appendChild(noSubcardsMsg);
  }
  
  subcardsPanel.appendChild(subcardsContainer);
  
  // Hide all cards
  const cards = container.querySelectorAll('.flashcard:not(.subcard)');
  cards.forEach(card => {
    card.style.display = 'none';
  });
  
  // Show the panel
  subcardsPanel.style.display = 'block';
  setTimeout(() => {
    subcardsPanel.classList.add('active');
  }, 50);
}

function closeSubcardsModal() {
  document.getElementById('subcardsModal').style.display = 'none';
}

// Function to exit subcards panel in fullscreen mode
function exitSubcardsPanel() {
  const container = document.querySelector('.flashcard-container');
  const subcardsPanel = container.querySelector('.subcards-panel-container');
  
  // Hide the panel with animation
  subcardsPanel.classList.remove('active');
  
  // Show all cards again
  const cards = container.querySelectorAll('.flashcard:not(.subcard)');
  cards.forEach(card => {
    card.style.display = 'block';
  });
  
  // Remove panel after animation completes
  setTimeout(() => {
    subcardsPanel.style.display = 'none';
  }, 300);
}

// Function to create a subcard element for the panel
function createSubcardForPanel(subcard) {
  const subcardElement = document.createElement('div');
  subcardElement.className = 'flashcard subcard panel-subcard';
  subcardElement.dataset.subcardId = subcard.id;
  
  const subcardInner = document.createElement('div');
  subcardInner.className = 'flashcard-inner';
  subcardInner.innerHTML = `
    <div class="flashcard-front">
      <div>${subcard.question}</div>
    </div>
    <div class="flashcard-back">${subcard.answer}</div>
  `;
  
  subcardElement.onclick = () => {
    subcardElement.classList.toggle('flipped');
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([subcardElement.querySelector('.flashcard-back')]).catch(err => console.log(err.message));
      }
    }, 500);
  };
  
  subcardElement.appendChild(subcardInner);
  return subcardElement;
}

/******************************
 * Modal Functions for Expanded Note *
 ******************************/
function openNoteModal(noteCard) {
  const noteModal = document.getElementById('noteModal');
  noteModal.innerHTML = '';
  const modalContent = document.createElement('div');
  modalContent.className = 'modal-content';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'close-modal';
  closeBtn.textContent = '×';
  closeBtn.onclick = closeNoteModal;
  modalContent.appendChild(closeBtn);
  const modalTitle = document.createElement('h2');
  modalTitle.textContent = noteCard.question;
  modalTitle.style.textAlign = 'center';
  modalContent.appendChild(modalTitle);
  const contentDiv = document.createElement('div');
  contentDiv.innerHTML = noteCard.answer;
  contentDiv.style.marginTop = '20px';
  modalContent.appendChild(contentDiv);
  noteModal.appendChild(modalContent);
  noteModal.style.display = 'flex';
  if (window.MathJax) {
    MathJax.typesetPromise([contentDiv]).catch(err => console.log(err.message));
  }
}

function closeNoteModal() {
  document.getElementById('noteModal').style.display = 'none';
}

function exportCards() {
      const data = {
        cards: currentCards,
        connections: connections
      };
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'flashcards_export.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importCards(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          if (!data.cards || !Array.isArray(data.cards)) {
            throw new Error('Invalid file format: Missing or invalid cards array');
          }
          currentCards = data.cards.map(card => ({
            ...card,
            id: card.id || Date.now().toString(),
            createdAt: card.createdAt || new Date().toISOString(),
            subcards: Array.isArray(card.subcards) ? card.subcards.map(subcard => ({
              ...subcard,
              id: subcard.id || Date.now().toString()
            })) : []
          }));
          connections = Array.isArray(data.connections) ? data.connections : [];
          saveCards();
          saveConnections();
          filterCards();
          alert('Cards imported successfully!');
        } catch (error) {
          alert('Error importing cards: ' + error.message);
        }
      };
      reader.readAsText(file);
      event.target.value = ''; // Reset file input
    }
/******************************
 * Edit Panel Modal Functions *
 ******************************/
function openEditPanel(card, onClose) {
  // Check if we're in fullscreen mode
  const container = document.querySelector('.flashcard-container');
  const isFullscreen = container.classList.contains('fullscreen-mode') || document.fullscreenElement;
  
  // Create or get the edit panel modal
  let editPanelModal = document.getElementById('editPanelModal');
  if (!editPanelModal) {
    editPanelModal = document.createElement('div');
    editPanelModal.id = 'editPanelModal';
    
    // Append to the fullscreen container if in fullscreen mode, otherwise to body
    if (isFullscreen) {
      container.appendChild(editPanelModal);
    } else {
      document.body.appendChild(editPanelModal);
    }
  } else {
    // If the modal already exists but we need to move it to the correct container
    if (isFullscreen && editPanelModal.parentElement !== container) {
      if (editPanelModal.parentElement) {
        editPanelModal.parentElement.removeChild(editPanelModal);
      }
      container.appendChild(editPanelModal);
    } else if (!isFullscreen && editPanelModal.parentElement !== document.body) {
      if (editPanelModal.parentElement) {
        editPanelModal.parentElement.removeChild(editPanelModal);
      }
      document.body.appendChild(editPanelModal);
    }
  }
  
  // Clear previous content
  editPanelModal.innerHTML = '';
  
  // Create modal content
  const modalContent = document.createElement('div');
  modalContent.className = 'edit-panel-content';
  
  // Create header
  const header = document.createElement('div');
  header.className = 'edit-panel-header';
  
  const title = document.createElement('h2');
  title.className = 'edit-panel-title';
  title.textContent = 'Edit Card';
  
  const closeBtn = document.createElement('button');
  closeBtn.className = 'close-edit-panel';
  closeBtn.innerHTML = '&times;';
  closeBtn.onclick = () => {
    closeEditPanel();
    if (onClose) onClose();
  };
  
  header.appendChild(title);
  header.appendChild(closeBtn);
  modalContent.appendChild(header);
  
  // Create form
  const form = document.createElement('div');
  form.className = 'edit-panel-form';
  
  // Category input
  const categoryGroup = document.createElement('div');
  categoryGroup.className = 'form-group';
  
  const categoryLabel = document.createElement('label');
  categoryLabel.textContent = 'Category';
  categoryLabel.setAttribute('for', 'edit-panel-category');
  
  const categoryInput = document.createElement('input');
  categoryInput.type = 'text';
  categoryInput.id = 'edit-panel-category';
  categoryInput.value = card.category || '';
  categoryInput.placeholder = 'Enter category';
  categoryInput.setAttribute('list', 'categoryList');
  
  categoryGroup.appendChild(categoryLabel);
  categoryGroup.appendChild(categoryInput);
  form.appendChild(categoryGroup);
  
  // Question/Title input
  const questionGroup = document.createElement('div');
  questionGroup.className = 'form-group';
  
  const questionLabel = document.createElement('label');
  questionLabel.textContent = card.type === 'note' ? 'Title' : 'Question';
  questionLabel.setAttribute('for', 'edit-panel-question');
  
  const questionInput = document.createElement('input');
  questionInput.type = 'text';
  questionInput.id = 'edit-panel-question';
  questionInput.value = card.question || '';
  questionInput.placeholder = card.type === 'note' ? 'Enter title' : 'Enter question';
  
  questionGroup.appendChild(questionLabel);
  questionGroup.appendChild(questionInput);
  form.appendChild(questionGroup);
  
  // Answer/Content input
  const answerGroup = document.createElement('div');
  answerGroup.className = 'form-group';
  
  const answerLabel = document.createElement('label');
  answerLabel.textContent = card.type === 'note' ? 'Content' : 'Answer';
  answerLabel.setAttribute('for', 'edit-panel-answer');
  
  const answerInput = document.createElement('textarea');
  answerInput.id = 'edit-panel-answer';
  answerInput.value = card.answer || '';
  answerInput.placeholder = card.type === 'note' ? 'Enter note content (LaTeX supported)' : 'Enter answer (LaTeX supported)';
  answerInput.rows = card.type === 'note' ? 8 : 5;
  
  answerGroup.appendChild(answerLabel);
  answerGroup.appendChild(answerInput);
  form.appendChild(answerGroup);
  
  // Button group
  const buttonGroup = document.createElement('div');
  buttonGroup.className = 'button-group';
  
  const saveBtn = document.createElement('button');
  saveBtn.className = 'save-btn';
  saveBtn.textContent = 'Save Changes';
  saveBtn.onclick = () => {
    // Save changes to card
    card.category = categoryInput.value.trim();
    card.question = questionInput.value.trim();
    card.answer = answerInput.value.trim();
    
    // Save cards and re-render
    saveCards();
    renderCards();
    
    // Close modal
    closeEditPanel();
    if (onClose) onClose();
  };
  
  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'cancel-btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = () => {
    closeEditPanel();
    if (onClose) onClose();
  };
  
  buttonGroup.appendChild(saveBtn);
  buttonGroup.appendChild(cancelBtn);
  form.appendChild(buttonGroup);
  
  // Subcards section (if applicable)
  if (card.type !== 'subcard') {
    const subcardsSection = document.createElement('div');
    subcardsSection.className = 'subcards-section';
    
    const subcardsHeader = document.createElement('div');
    subcardsHeader.className = 'subcards-header';
    
    const subcardsTitle = document.createElement('h3');
    subcardsTitle.textContent = 'Subcards';
    
    const addSubcardBtn = document.createElement('button');
    addSubcardBtn.className = 'add-subcard-btn';
    addSubcardBtn.textContent = '+ Add Subcard';
    addSubcardBtn.onclick = () => {
      const newSubcard = {
        id: `card-${Date.now()}-${Math.random()}`,
        question: 'New Subcard',
        answer: 'Subcard answer',
        type: 'subcard'
      };
      
      if (!card.subcards) card.subcards = [];
      card.subcards.push(newSubcard);
      
      // Re-render subcards in the modal
      renderSubcardsInEditPanel(card, subcardsContainer);
    };
    
    subcardsHeader.appendChild(subcardsTitle);
    subcardsHeader.appendChild(addSubcardBtn);
    subcardsSection.appendChild(subcardsHeader);
    
    const subcardsContainer = document.createElement('div');
    subcardsContainer.className = 'subcards-container';
    
    // Render existing subcards
    renderSubcardsInEditPanel(card, subcardsContainer);
    
    subcardsSection.appendChild(subcardsContainer);
    form.appendChild(subcardsSection);
  }
  
  modalContent.appendChild(form);
  editPanelModal.appendChild(modalContent);
  
  // Display the modal with animation
  editPanelModal.style.display = 'flex';
  setTimeout(() => {
    editPanelModal.classList.add('active');
  }, 10);
}

function renderSubcardsInEditPanel(card, container) {
  // Clear container
  container.innerHTML = '';
  
  // Check if card has subcards
  if (!card.subcards || card.subcards.length === 0) {
    const noSubcardsMsg = document.createElement('p');
    noSubcardsMsg.textContent = 'No subcards yet. Add one to get started.';
    noSubcardsMsg.style.color = '#888';
    noSubcardsMsg.style.fontStyle = 'italic';
    container.appendChild(noSubcardsMsg);
    return;
  }
  
  // Render each subcard
  card.subcards.forEach(subcard => {
    const subcardElement = document.createElement('div');
    subcardElement.className = 'flashcard subcard';
    subcardElement.style.position = 'relative';
    
    // Create delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.style.opacity = '1';
    deleteBtn.onclick = (e) => {
      e.stopPropagation();
      card.subcards = card.subcards.filter(sc => sc.id !== subcard.id);
      renderSubcardsInEditPanel(card, container);
    };
    
    // Create edit button
    const editBtn = document.createElement('button');
    editBtn.className = 'edit-btn';
    editBtn.textContent = '✎';
    editBtn.style.opacity = '1';
    editBtn.onclick = (e) => {
      e.stopPropagation();
      enableSubcardEditInPanel(subcardElement, subcard, card, container);
    };
    
    // Create subcard content
    const subcardInner = document.createElement('div');
    subcardInner.className = 'flashcard-inner';
    subcardInner.innerHTML = `
      <div class="flashcard-front">
        <div>${subcard.question}</div>
      </div>
      <div class="flashcard-back">${subcard.answer}</div>
    `;
    
    // Add click handler to flip
    subcardElement.onclick = () => {
      subcardElement.classList.toggle('flipped');
    };
    
    subcardElement.appendChild(deleteBtn);
    subcardElement.appendChild(editBtn);
    subcardElement.appendChild(subcardInner);
    container.appendChild(subcardElement);
  });
}

function enableSubcardEditInPanel(subcardElement, subcard, parentCard, container) {
  subcardElement.classList.add('editing');
  const subcardInner = subcardElement.querySelector('.flashcard-inner');
  const originalContent = subcardInner.innerHTML;
  
  // Create edit form
  const editForm = document.createElement('div');
  editForm.className = 'edit-mode';
  
  // Question input
  const questionInput = document.createElement('input');
  questionInput.type = 'text';
  questionInput.value = subcard.question;
  questionInput.placeholder = 'Subcard Question';
  
  // Answer input
  const answerInput = document.createElement('textarea');
  answerInput.rows = 4;
  answerInput.value = subcard.answer;
  answerInput.placeholder = 'Subcard Answer (LaTeX supported)';
  
  // Button group
  const buttonGroup = document.createElement('div');
  buttonGroup.className = 'button-group';
  
  // Save button
  const saveBtn = document.createElement('button');
  saveBtn.className = 'save-btn';
  saveBtn.textContent = 'Save';
  saveBtn.onclick = (e) => {
    e.stopPropagation();
    subcard.question = questionInput.value.trim();
    subcard.answer = answerInput.value.trim();
    renderSubcardsInEditPanel(parentCard, container);
  };
  
  // Cancel button
  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'cancel-btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = (e) => {
    e.stopPropagation();
    subcardInner.innerHTML = originalContent;
    subcardElement.classList.remove('editing');
  };
  
  // Assemble form
  buttonGroup.appendChild(saveBtn);
  buttonGroup.appendChild(cancelBtn);
  editForm.appendChild(questionInput);
  editForm.appendChild(answerInput);
  editForm.appendChild(buttonGroup);
  
  // Replace content with form - FIXED: Clear inner HTML first
  subcardInner.innerHTML = '';
  subcardInner.appendChild(editForm);
  
  // Fix: Add background color and apply expanded class for proper visibility
  editForm.style.backgroundColor = '#fff';
  
  // Apply the expanded class after a short delay to trigger the transition
  setTimeout(() => {
    editForm.classList.add('expanded');
  }, 10);
}

function closeEditPanel() {
  const editPanelModal = document.getElementById('editPanelModal');
  if (editPanelModal) {
    editPanelModal.classList.remove('active');
    setTimeout(() => {
      editPanelModal.style.display = 'none';
    }, 300);
  }
}

/******************************
 * Subcard Creation Functions *
 ******************************/
function createSubcard(subcard, parentCard) {
  const subcardElement = document.createElement('div');
  subcardElement.className = 'flashcard subcard';
  subcardElement.dataset.subcardId = subcard.id;
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-btn';
  deleteBtn.textContent = '×';
  deleteBtn.onclick = (e) => {
    e.stopPropagation();
    parentCard.subcards = parentCard.subcards.filter(sc => sc.id !== subcard.id);
    saveCards();
    renderCards();
  };
  const editBtn = document.createElement('button');
  editBtn.className = 'edit-btn';
  editBtn.textContent = '✎';
  editBtn.onclick = (e) => {
    e.stopPropagation();
    enableSubcardEditMode(subcardElement, subcard, parentCard);
  };
  const subcardInner = document.createElement('div');
  subcardInner.className = 'flashcard-inner';
  subcardInner.innerHTML = `
    <div class="flashcard-front">
      <div>${subcard.question}</div>
    </div>
    <div class="flashcard-back">${subcard.answer}</div>
  `;
  subcardElement.onclick = (e) => {
    e.stopPropagation();
    if (subcardElement.classList.contains('editing')) return;
    openSubcardsModal(parentCard);
  };
  subcardElement.appendChild(deleteBtn);
  subcardElement.appendChild(editBtn);
  subcardElement.appendChild(subcardInner);
  return subcardElement;
}

function createSubcardForModal(subcard) {
  const subcardElement = document.createElement('div');
  subcardElement.className = 'flashcard subcard';
  subcardElement.dataset.subcardId = subcard.id;
  const subcardInner = document.createElement('div');
  subcardInner.className = 'flashcard-inner';
  subcardInner.innerHTML = `
    <div class="flashcard-front">
      <div>${subcard.question}</div>
    </div>
    <div class="flashcard-back">${subcard.answer}</div>
  `;
  subcardElement.onclick = () => {
    subcardElement.classList.toggle('flipped');
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([subcardElement.querySelector('.flashcard-back')]).catch(err => console.log(err.message));
      }
    }, 500);
  };
  subcardElement.appendChild(subcardInner);
  return subcardElement;
}

/******************************
 * Card Creation Functions    *
 ******************************/
function createCard(card) {
  const cardElement = document.createElement('div');
  cardElement.className = 'flashcard';
  if (card.type === "note") cardElement.classList.add("note");
  cardElement.dataset.cardId = card.id;
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-btn';
  deleteBtn.textContent = '×';
  deleteBtn.onclick = (e) => {
    e.stopPropagation();
    currentCards = currentCards.filter(c => c.id !== card.id);
    saveCards();
    renderCards();
  };
  const editBtn = document.createElement('button');
  editBtn.className = 'edit-btn';
  editBtn.textContent = '✎';
  editBtn.onclick = (e) => {
    e.stopPropagation();
    enableEditMode(cardElement, card);
  };
  const cardInner = document.createElement('div');
  cardInner.className = 'flashcard-inner';
  cardInner.innerHTML = `
    <div class="flashcard-front">
      ${card.category ? `<div style="font-weight:bold; margin-bottom:8px;">${card.category}</div>` : ''}
      <div>${card.question}</div>
    </div>
    <div class="flashcard-back">${card.answer}</div>
  `;
  cardElement.onclick = () => {
    if (!cardElement.classList.contains('editing')) {
      cardElement.classList.toggle('flipped');
      setTimeout(() => {
        if (window.MathJax) {
          MathJax.typesetPromise([cardInner.querySelector('.flashcard-back')]).catch(err => console.log(err.message));
        }
      }, 500);
    }
  };
  cardElement.appendChild(deleteBtn);
  cardElement.appendChild(editBtn);
  cardElement.appendChild(cardInner);
  if (card.subcards && card.subcards.length > 0) {
    const toggleSubcardsBtn = document.createElement('button');
    toggleSubcardsBtn.textContent = 'Show Subcards';
    toggleSubcardsBtn.style.marginTop = '10px';
    toggleSubcardsBtn.style.padding = '6px 12px';
    toggleSubcardsBtn.style.background = '#667eea';
    toggleSubcardsBtn.style.color = '#fff';
    toggleSubcardsBtn.style.border = 'none';
    toggleSubcardsBtn.style.borderRadius = '5px';
    toggleSubcardsBtn.style.cursor = 'pointer';
    toggleSubcardsBtn.onclick = (e) => {
      e.stopPropagation();
      openSubcardsModal(card);
    };
    cardElement.appendChild(toggleSubcardsBtn);
  }
  if (card.type === "note") {
    const expandBtn = document.createElement('button');
    expandBtn.textContent = 'Expand';
    expandBtn.style.marginTop = '10px';
    expandBtn.style.padding = '6px 12px';
    expandBtn.style.background = '#28a745';
    expandBtn.style.color = '#fff';
    expandBtn.style.border = 'none';
    expandBtn.style.borderRadius = '5px';
    expandBtn.style.cursor = 'pointer';
    expandBtn.onclick = (e) => {
      e.stopPropagation();
      openNoteModal(card);
    };
    cardElement.appendChild(expandBtn);
  }
  return cardElement;
}

/******************************
 * Edit Mode Functions        *
 ******************************/
function enableSubcardEditMode(subcardElement, subcard, parentCard) {
  subcardElement.classList.add('editing');
  const subcardInner = subcardElement.querySelector('.flashcard-inner');
  const originalContent = subcardInner.innerHTML;
  subcardInner.innerHTML = '';
  const editContainer = document.createElement('div');
  editContainer.className = 'edit-mode';
  const questionInput = document.createElement('input');
  questionInput.type = 'text';
  questionInput.value = subcard.question;
  questionInput.placeholder = 'Subcard Question';
  const answerInput = document.createElement('textarea');
  answerInput.rows = 4;
  answerInput.value = subcard.answer;
  answerInput.placeholder = 'Subcard Answer (LaTeX supported)';
  const saveBtn = document.createElement('button');
  saveBtn.className = 'save-btn';
  saveBtn.textContent = 'Save';
  saveBtn.onclick = (e) => {
    e.stopPropagation();
    subcard.question = questionInput.value.trim();
    subcard.answer = answerInput.value.trim();
    saveCards();
    renderCards();
  };
  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'cancel-btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = (e) => {
    e.stopPropagation();
    subcardInner.innerHTML = originalContent;
    subcardElement.classList.remove('editing');
  };
  editContainer.appendChild(questionInput);
  editContainer.appendChild(answerInput);
  editContainer.appendChild(saveBtn);
  editContainer.appendChild(cancelBtn);
  subcardInner.appendChild(editContainer);
  
  // Fix: Add background color and apply expanded class for proper visibility
  editContainer.style.backgroundColor = '#fff';
  
  // Apply the expanded class after a short delay to trigger the transition
  setTimeout(() => {
    editContainer.classList.add('expanded');
  }, 10);
}

function enableEditMode(cardElement, card) {
  cardElement.classList.add('editing');
  const cardInner = cardElement.querySelector('.flashcard-inner');
  const originalContent = cardInner.innerHTML;
  
  // Check if we're in fullscreen mode
  const isFullscreen = document.fullscreenElement;
  
  if (isFullscreen) {
    // Create edit panel for fullscreen mode
    openEditPanel(card, () => {
      cardElement.classList.remove('editing');
    });
  } else {
    // Regular edit mode (non-fullscreen)
    const editContainer = document.createElement('div');
    editContainer.className = 'edit-mode';
    const categoryInput = document.createElement('input');
    categoryInput.type = 'text';
    categoryInput.value = card.category || '';
    categoryInput.placeholder = 'Category';
    categoryInput.setAttribute('list', 'categoryList');
    const questionInput = document.createElement('input');
    questionInput.type = 'text';
    questionInput.value = card.question || '';
    questionInput.placeholder = 'Question / Title';
    const answerInput = document.createElement('textarea');
    answerInput.rows = card.type === "note" ? 6 : 4;
    answerInput.value = card.answer || '';
    answerInput.placeholder = 'Answer or note content (LaTeX supported)';
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'button-group';
    const saveBtn = document.createElement('button');
    saveBtn.className = 'save-btn';
    saveBtn.textContent = 'Save Changes';
    saveBtn.onclick = (e) => {
      e.stopPropagation();
      
      // Trigger close animation first
      editContainer.classList.remove('expanded');
      
      // Add delay to allow animation to complete before updating
      setTimeout(() => {
        card.category = categoryInput.value.trim();
        card.question = questionInput.value.trim();
        card.answer = answerInput.value.trim();
        saveCards();
        renderCards();
      }, 400); // Match this with transition time
    };
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'cancel-btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      
      // Trigger close animation first
      editContainer.classList.remove('expanded');
      
      // Wait for animation to complete before restoring original content
      setTimeout(() => {
        cardInner.innerHTML = originalContent;
        cardElement.classList.remove('editing');
      }, 400); // Match this with transition time
    };
    buttonGroup.appendChild(saveBtn);
    buttonGroup.appendChild(cancelBtn);
    const subcardsSection = document.createElement('div');
    subcardsSection.className = 'subcards-section';
    const subcardsHeader = document.createElement('div');
    subcardsHeader.className = 'subcards-header';
    const subcardsLabel = document.createElement('h3');
    subcardsLabel.textContent = 'Subcards';
    const addSubcardBtn = document.createElement('button');
    addSubcardBtn.className = 'add-subcard-btn';
    addSubcardBtn.textContent = '+ Add Subcard';
    addSubcardBtn.onclick = (e) => {
      e.stopPropagation();
      const newSubcard = {
        id: `card-${Date.now()}-${Math.random()}`,
        question: 'New Subcard',
        answer: 'Subcard answer',
        type: 'subcard'
      };
      if (!card.subcards) card.subcards = [];
      card.subcards.push(newSubcard);
      saveCards();
      renderCards();
    };
    subcardsHeader.appendChild(subcardsLabel);
    subcardsHeader.appendChild(addSubcardBtn);
    const subcardsContainer = document.createElement('div');
    subcardsContainer.className = 'subcards-container';
    if (!card.subcards) card.subcards = [];
    card.subcards.forEach(subcard => {
      subcardsContainer.appendChild(createSubcard(subcard, card));
    });
    editContainer.appendChild(categoryInput);
    editContainer.appendChild(questionInput);
    editContainer.appendChild(answerInput);
    editContainer.appendChild(buttonGroup);
    editContainer.appendChild(subcardsSection);
    subcardsSection.appendChild(subcardsHeader);
    subcardsSection.appendChild(subcardsContainer);
    cardInner.innerHTML = '';
    cardInner.appendChild(editContainer);
    
    // Trigger animation after DOM update (using setTimeout with 0 delay)
    setTimeout(() => {
      editContainer.classList.add('expanded');
    }, 10);
  }
}

/******************************
 * Adding New Cards / Notes   *
 ******************************/
function addNewCard() {
  const categoryInput = document.getElementById('category');
  const questionInput = document.getElementById('question');
  const answerInput = document.getElementById('answer');
  const category = categoryInput.value.trim();
  const question = questionInput.value.trim();
  const answer = answerInput.value.trim();
  if (question && answer) {
    currentCards.push({
      id: `card-${Date.now()}-${Math.random()}`,
      category,
      question,
      answer,
      type: "card"
    });
    saveCards();
    renderCards();
    categoryInput.value = '';
    questionInput.value = '';
    answerInput.value = '';
  }
}

function addNewNote() {
  const categoryInput = document.getElementById('category');
  const questionInput = document.getElementById('question');
  const answerInput = document.getElementById('answer');
  const category = categoryInput.value.trim();
  const question = questionInput.value.trim();
  const answer = answerInput.value.trim();
  if (question && answer) {
    currentCards.push({
      id: `card-${Date.now()}-${Math.random()}`,
      category,
      question,
      answer,
      type: "note"
    });
    saveCards();
    renderCards();
    categoryInput.value = '';
    questionInput.value = '';
    answerInput.value = '';
  }
}

function shuffleCards() {
  for (let i = currentCards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [currentCards[i], currentCards[j]] = [currentCards[j], currentCards[i]];
  }
  saveCards();
  renderCards();
}

/******************************
 * Connexion Mode Functions   *
 ******************************/
function enterConnexionMode() {
  loadConnections();
  const filterValue = document.getElementById('filterCategory').value;
  const filteredCards = filterValue === 'all'
    ? currentCards
    : currentCards.filter(card => card.category === filterValue);
  if (filteredCards.length === 0) {
    alert('No cards to connect in the selected category!');
    return;
  }
  isSegregated = false;
  originalPositions = {};
  assignInitialPositions(filteredCards);
  currentFilteredCards = filteredCards;
  renderConnexionCanvas(filteredCards);
  document.getElementById('cardContainer').style.display = 'none';
  document.getElementById('connexionCanvas').style.display = 'block';
  document.querySelector('.input-panel').style.display = 'none';
  document.querySelector('.button-panel').style.display = 'none';
  

  if (!globalEventHandlersInitialized) {
    initializeGlobalEventHandlers();
    globalEventHandlersInitialized = true;
  }
}

function exitConnexionMode() {
  activeConnectionCreation = false;
  document.getElementById('cardContainer').style.display = 'flex';
  document.getElementById('connexionCanvas').style.display = 'none';
  document.querySelector('.input-panel').style.display = 'flex';
  document.querySelector('.button-panel').style.display = 'flex';
  
  // Force a refresh of the button panel to maintain layout
  resetButtonPanel();
  
  saveCards();
  saveConnections();
  renderCards();
}

function initializeGlobalEventHandlers() {
  document.addEventListener('mousemove', handleGlobalMouseMove);
  document.addEventListener('mouseup', handleGlobalMouseUp);
}

function handleGlobalMouseMove(e) {
  if (!activeDrag.isDragging) return;
  const newLeft = e.clientX - activeDrag.startX;
  const newTop = e.clientY - activeDrag.startY;
  activeDrag.element.style.left = `${newLeft}px`;
  activeDrag.element.style.top = `${newTop}px`;
  if (activeDrag.element.classList.contains('connexion-card')) {
    const cardId = activeDrag.element.dataset.id;
    const card = currentCards.find(c => c.id === cardId);
    if (card) {
      card.x = newLeft;
      card.y = newTop;
      if (!activeConnectionCreation) {
        highlightNearbyCards(card);
      }
    }
  }
}

function handleGlobalMouseUp(e) {
  if (!activeDrag.isDragging) return;
  const element = activeDrag.element;
  element.style.zIndex = '';
  if (element.classList.contains('connexion-card')) {
    const cardId = element.dataset.id;
    const card = currentCards.find(c => c.id === cardId);
    if (card && !activeConnectionCreation) {
      detectAndCreateConnections(card, currentFilteredCards);
    }
  }
  activeDrag.isDragging = false;
  activeDrag.element = null;
}

function assignInitialPositions(cards) {
  const gridSize = 220;
  const numCols = Math.floor(window.innerWidth / gridSize);
  cards.forEach((card, index) => {
    if (card.x === undefined || card.y === undefined) {
      const row = Math.floor(index / numCols);
      const col = index % numCols;
      card.x = col * gridSize + 50;
      card.y = row * gridSize + 50;
    }
  });
}

function renderConnexionCanvas(cards) {
  const canvas = document.getElementById('connexionCanvas');
  canvas.innerHTML = '';
  const backBtn = document.createElement('button');
  backBtn.textContent = 'Back to Flashcards';
  backBtn.style.position = 'absolute';
  backBtn.style.top = '10px';
  backBtn.style.left = '10px';
  backBtn.style.padding = '10px 20px';
  backBtn.style.background = '#ff4757';
  backBtn.style.color = '#fff';
  backBtn.style.border = 'none';
  backBtn.style.borderRadius = '5px';
  backBtn.style.cursor = 'pointer';
  backBtn.style.zIndex = '1000';
  backBtn.onclick = exitConnexionMode;
  canvas.appendChild(backBtn);
  const segregateBtn = document.createElement('button');
  segregateBtn.id = 'segregateBtn';
  segregateBtn.textContent = isSegregated ? 'Restore' : 'Segregate';
  segregateBtn.style.position = 'absolute';
  segregateBtn.style.top = '10px';
  segregateBtn.style.right = '10px';
  segregateBtn.style.padding = '10px 20px';
  segregateBtn.style.background = '#28a745';
  segregateBtn.style.color = '#fff';
  segregateBtn.style.border = 'none';
  segregateBtn.style.borderRadius = '5px';
  segregateBtn.style.cursor = 'pointer';
  segregateBtn.style.zIndex = '1000';
  segregateBtn.onclick = () => toggleSegregate(cards);
  canvas.appendChild(segregateBtn);
  const toggleViewBtn = document.createElement('button');
  toggleViewBtn.id = 'toggleViewBtn';
  toggleViewBtn.className = 'mind-map-button';
  toggleViewBtn.textContent = 'Mind Map View';
  toggleViewBtn.style.position = 'absolute';
  toggleViewBtn.style.top = '10px';
  toggleViewBtn.style.left = '170px';
  toggleViewBtn.style.padding = '10px 15px';

  toggleViewBtn.style.color = ' linear-gradient(45deg, #2c3e50, #3498db)';
  toggleViewBtn.style.border = 'none';
  toggleViewBtn.style.borderRadius = '5px';
  toggleViewBtn.style.cursor = 'pointer';
  toggleViewBtn.style.zIndex = '1000';
  toggleViewBtn.onclick = toggleMindMapView;
  canvas.appendChild(toggleViewBtn);
  const gridView = document.createElement('div');
  gridView.id = 'gridView';
  gridView.style.position = 'relative';
  gridView.style.width = '100%';
  gridView.style.height = '100%';
  canvas.appendChild(gridView);
  const mindMapView = document.createElement('div');
  mindMapView.id = 'mindMapView';
  mindMapView.style.position = 'absolute';
  mindMapView.style.top = '0';
  mindMapView.style.left = '0';
  mindMapView.style.width = '100%';
  mindMapView.style.height = '100%';
  mindMapView.style.display = 'none';
  canvas.appendChild(mindMapView);
  const connectedCardIds = new Set(connections.flatMap(conn => conn.cards));
  const unconnectedCards = cards.filter(card => !connectedCardIds.has(card.id));
  unconnectedCards.forEach(card => {
    const cardDiv = createConnexionCard(card, false);
    cardDiv.style.left = `${card.x}px`;
    cardDiv.style.top = `${card.y}px`;
    gridView.appendChild(cardDiv);
    makeDraggable(cardDiv, card, cards);
  });
  const panelWidth = 450;
  const panelHeight = 200;
  const margin = 20;
  let panelX = 20;
  let panelY = 60;
  const canvasWidth = gridView.clientWidth || canvas.clientWidth;
  connections.forEach(conn => {
  if (!conn.cards || !Array.isArray(conn.cards)) {
    console.warn('Connection missing cards array:', conn);
    return;
  }
    const connCards = conn.cards.map(id => cards.find(c => c.id === id)).filter(Boolean);
    if (connCards.length === conn.cards.length) {
      const panel = document.createElement('div');
      panel.className = 'connection-panel';
      panel.style.position = 'absolute';
      panel.style.left = `${panelX}px`;
      panel.style.top = `${panelY}px`;
      panel.style.border = `2px solid ${conn.color || '#000'}`;
      panel.innerHTML = `
        <div class="connection-cards">
          ${conn.cards.map(cardId => {
            const card = cards.find(c => c.id === cardId);
            return `
              <div class="connection-card">
                <h4>${card.category || 'General'}</h4>
                <p>${card.question}</p>
              </div>
            `;
          }).join('')}
        </div>
        <div class="connection-description">${conn.description}</div>
        <div class="connection-buttons">
          <button class="edit-connection">Edit</button>
          <button class="view-connection">View</button>
          <button class="remove-connection">Remove</button>
        </div>
      `;
      gridView.appendChild(panel);
      makePanelDraggable(panel);
      panel.querySelector('.edit-connection').addEventListener('click', () => editConnection(conn.id, cards));
      panel.querySelector('.view-connection').addEventListener('click', () => viewConnection(conn.id, cards));
      panel.querySelector('.remove-connection').addEventListener('click', () => removeConnection(conn.id, cards));
      panelX += panelWidth + margin;
      if (panelX + panelWidth > canvasWidth) {
        panelX = 20;
        panelY += panelHeight + margin;
      }
    }
  });
}

function createConnexionCard(card, inContainer) {
  const cardDiv = document.createElement('div');
  cardDiv.className = 'connexion-card';
  cardDiv.dataset.id = card.id;
  cardDiv.style.position = 'absolute';
  cardDiv.style.width = '200px';
  cardDiv.style.height = '150px';
  cardDiv.style.backgroundColor = card.color || '#f0f0f0';
  cardDiv.innerHTML = `
    <div class="connexion-card-inner">
      <div class="connexion-card-front">
        <h4>${card.category || 'General'}</h4>
        <p>${card.question}</p>
      </div>
      <div class="connexion-card-back">
        <p>${card.answer}</p>
      </div>
    </div>
  `;
  cardDiv.addEventListener('dblclick', (e) => {
    e.stopPropagation();
    cardDiv.classList.toggle('flipped');
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([cardDiv.querySelector('.connexion-card-back')]).catch(err => console.log(err.message));
      }
    }, 500);
  });
  if (!inContainer) {
    makeDraggable(cardDiv, card, currentFilteredCards);
  }
  return cardDiv;
}

function makeDraggable(element, card, allCards) {
  let isDragging = false;
  let startX, startY;
  element.addEventListener('mousedown', e => {
    isDragging = true;
    startX = e.clientX - element.offsetLeft;
    startY = e.clientY - element.offsetTop;
    element.style.zIndex = '1000';
    activeDrag = { element, isDragging: true, startX, startY };
  });
  document.addEventListener('mousemove', e => {
    if (isDragging) {
      const newLeft = e.clientX - startX;
      const newTop = e.clientY - startY;
      element.style.left = `${newLeft}px`;
      element.style.top = `${newTop}px`;
      card.x = newLeft;
      card.y = newTop;
      allCards.forEach(otherCard => {
        if (otherCard.id !== card.id) {
          const otherElem = document.querySelector(`.connexion-card[data-id="${otherCard.id}"]`);
          if (otherElem) {
            const cardRect = element.getBoundingClientRect();
            const otherRect = otherElem.getBoundingClientRect();
            if (Math.abs(cardRect.left - otherRect.left) < 100 && Math.abs(cardRect.top - otherRect.top) < 100) {
              otherElem.style.border = '2px solid red';
            } else {
              otherElem.style.border = '';
            }
          }
        }
      });
    }
  });
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      element.style.zIndex = '';
    }
  });
}

function makePanelDraggable(element) {
  let isDragging = false;
  let startX, startY;
  element.addEventListener('mousedown', e => {
    isDragging = true;
    startX = e.clientX - element.offsetLeft;
    startY = e.clientY - element.offsetTop;
    element.style.zIndex = '1000';
  });
  document.addEventListener('mousemove', e => {
    if (isDragging) {
      const newLeft = e.clientX - startX;
      const newTop = e.clientY - startY;
      element.style.left = `${newLeft}px`;
      element.style.top = `${newTop}px`;
    }
  });
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      element.style.zIndex = '';
    }
  });
}

function detectAndCreateConnections(draggedCard, allCards) {
  const connectedCardIds = new Set(connections.flatMap(conn => conn.cards));
  const unconnectedCards = allCards.filter(card => !connectedCardIds.has(card.id));
  
  // If dragged card is already connected, return
  if (!unconnectedCards.some(card => card.id === draggedCard.id)) return;

  // Find nearby cards
  const nearbyCards = unconnectedCards.filter(card => {
    if (card.id === draggedCard.id) return false;
    
    // Calculate center points of cards
    const draggedElem = document.querySelector(`.connexion-card[data-id="${draggedCard.id}"]`);
    const cardElem = document.querySelector(`.connexion-card[data-id="${card.id}"]`);
    
    if (!draggedElem || !cardElem) return false;

    const draggedRect = draggedElem.getBoundingClientRect();
    const cardRect = cardElem.getBoundingClientRect();

    // Calculate centers
    const draggedCenter = {
      x: draggedRect.left + draggedRect.width / 2,
      y: draggedRect.top + draggedRect.height / 2
    };
    const cardCenter = {
      x: cardRect.left + cardRect.width / 2,
      y: cardRect.top + cardRect.height / 2
    };

    // Calculate distance between centers
    const distance = Math.sqrt(
      Math.pow(draggedCenter.x - cardCenter.x, 2) + 
      Math.pow(draggedCenter.y - cardCenter.y, 2)
    );

    // Return true if cards are close enough (150px threshold)
    return distance < 150;
  });

  // If we found nearby cards, create a connection
  if (nearbyCards.length > 0) {
    const cardsToConnect = [draggedCard, ...nearbyCards];
    const cardQuestions = cardsToConnect.map(c => c.question).join(', ');
    
    if (confirm(`Create a connection between these cards: ${cardQuestions}?`)) {
      const description = prompt('Enter a description for this connection:') || 'New connection';
      const connectionTag = prompt("Enter a tag for this connection (e.g., cause-effect, analogy):", "general");
      const connectionColor = prompt("Enter a color for this connection (hex code, e.g., #FF0000):", "#000000");
      
      const newConn = {
        id: `conn-${Date.now()}-${Math.random()}`,
        cards: cardsToConnect.map(c => c.id),
        description,
        tag: connectionTag,
        color: connectionColor
      };

      connections.push(newConn);
      saveConnections();
      renderConnexionCanvas(allCards);
    }
  }
}

// Original checkForNewConnection (kept for reference but not used)
function checkForNewConnection(card, allCards) {
  // This function is replaced by detectAndCreateConnections
}

function toggleSegregate(cards) {
  const canvas = document.getElementById('connexionCanvas');
  if (isSegregated) {
    Object.keys(originalPositions).forEach(id => {
      const elem = document.querySelector(`[data-id="${id}"]`) || document.querySelector(`.connection-panel[data-conn-id="${id}"]`);
      if (elem) {
        elem.style.left = originalPositions[id].x + 'px';
        elem.style.top = originalPositions[id].y + 'px';
      }
    });
    const separator = document.getElementById('separatorLine');
    if (separator) separator.remove();
    isSegregated = false;
    document.getElementById('segregateBtn').textContent = 'Segregate';
  } else {
    originalPositions = {};
    cards.forEach(card => {
      const elem = document.querySelector(`[data-id="${card.id}"]`);
      if (elem) {
        originalPositions[card.id] = { x: parseFloat(elem.style.left || card.x), y: parseFloat(elem.style.top || card.y) };
      }
    });
    connections.forEach(conn => {
      const panel = Array.from(document.querySelectorAll('.connection-panel')).find(p => p.dataset.connId === conn.id);
      if (panel) {
        originalPositions[conn.id] = { x: parseFloat(panel.style.left), y: parseFloat(panel.style.top) };
        panel.dataset.connId = conn.id;
      }
    });
    const panelWidth = 450;
    const cardWidth = 200;
    const margin = 20;
    let panelX = 20;
    let panelY = 40;
    connections.forEach(conn => {
      const panel = Array.from(document.querySelectorAll('.connection-panel')).find(p => p.dataset.connId === conn.id);
      if (panel) {
        panel.style.left = `${panelX}px`;
        panel.style.top = `${panelY}px`;
        panel.style.transition = 'all 0.5s ease';
        panelX += panelWidth + margin;
        if (panelX + panelWidth > canvas.clientWidth / 2) {
          panelX = 20;
          panelY += 220;
        }
      }
    });
    const connectedCardIds = new Set(connections.flatMap(conn => conn.cards));
    const unconnectedCards = cards.filter(card => !connectedCardIds.has(card.id));
    const cardHeight = 170;
    const rightSideStart = canvas.clientWidth / 2 + margin;
    const availableWidth = canvas.clientWidth / 2 - margin;
    const cardsPerRow = Math.floor(availableWidth / (cardWidth + margin));
    unconnectedCards.forEach((card, index) => {
      const row = Math.floor(index / cardsPerRow);
      const col = index % cardsPerRow;
      const x = rightSideStart + col * (cardWidth + margin);
      const y = 100 + row * (cardHeight + margin);
      const cardElem = document.querySelector(`.connexion-card[data-id="${card.id}"]`);
      if (cardElem) {
        cardElem.style.left = `${x}px`;
        cardElem.style.top = `${y}px`;
        cardElem.style.transition = 'all 0.5s ease';
        card.x = x;
        card.y = y;
      }
    });
    let separator = document.getElementById('separatorLine');
    if (!separator) {
      separator = document.createElement('div');
      separator.id = 'separatorLine';
      separator.style.position = 'absolute';
      separator.style.backgroundColor = 'black';
      separator.style.width = '2px';
      separator.style.top = '0';
      separator.style.height = canvas.clientHeight + 'px';
      canvas.appendChild(separator);
    }
    separator.style.left = canvas.clientWidth / 2 + 'px';
    isSegregated = true;
    document.getElementById('segregateBtn').textContent = 'Restore';
  }
}

function renderMindMap(cards, connections) {
  const container = d3.select("#mindMapView");
  if (container.empty()) {
    console.error("No container found with id 'mindMapView'");
    return;
  }
  container.selectAll("*").remove();
  const width = container.node().clientWidth || 800;
  const height = container.node().clientHeight || 600;
  const nodes = cards.map(card => ({
    id: card.id,
    question: card.question,
    category: card.category,
    color: card.color || "#ffffff",
    tag: card.tag || ""
  }));
  const links = [];
  connections.forEach(conn => {
    const cardIds = conn.cards;
    for (let i = 0; i < cardIds.length; i++) {
      for (let j = i + 1; j < cardIds.length; j++) {
        links.push({
          source: cardIds[i],
          target: cardIds[j],
          description: conn.description,
          color: conn.color || "#666666",
          tag: conn.tag || ""
        });
      }
    }
  });
  
  // Add zoom and pan functionality
  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid white")
    .call(d3.zoom().on("zoom", (event) => {
      g.attr("transform", event.transform);
    }));
    
  // Create a group for all elements to enable zooming
  const g = svg.append("g");
  
  // Rest of your code with g instead of svg for appending elements
  const nodeIds = new Set(nodes.map(node => node.id));
  const validLinks = links.filter(link => nodeIds.has(link.source) && nodeIds.has(link.target));

  // Add links with improved styling
  const link = g.append("g")
    .attr("stroke-opacity", 0.6)
    .selectAll("line")
    .data(validLinks)
    .enter().append("line")
    .attr("stroke", d => d.color)
    .attr("stroke-width", 2)
    .style("cursor", "pointer")
    .on("mouseover", function(event, d) {
      d3.select(this)
        .attr("stroke-width", 4)
        .attr("stroke-opacity", 1);
    })
    .on("mouseout", function(event, d) {
      d3.select(this)
        .attr("stroke-width", 2)
        .attr("stroke-opacity", 0.6);
    })
    .on("click", function(event, d) {
      // Show connection tooltip
      d3.select("#connection-tooltip").remove();
      const tooltip = g.append("g")
        .attr("id", "connection-tooltip")
        .attr("transform", `translate(${(d.source.x + d.target.x) / 2},${(d.source.y + d.target.y) / 2})`);
      
      const tooltipText = tooltip.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .attr("fill", "white")
        .text(d.description);
      
      const textBBox = tooltipText.node().getBBox();
      tooltip.insert("rect", "text")
        .attr("x", textBBox.x - 10)
        .attr("y", textBBox.y - 5)
        .attr("width", textBBox.width + 20)
        .attr("height", textBBox.height + 10)
        .attr("fill", "rgba(0, 0, 0, 0.8)")
        .attr("rx", 5);
      
      setTimeout(() => tooltip.remove(), 3000);
    });

  // Add nodes with improved interaction
  const nodeGroup = g.append("g")
    .selectAll("g")
    .data(nodes)
    .enter().append("g")
    .attr("class", "node-group")
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  // Add node background rectangles
  nodeGroup.append("rect")
    .attr("rx", 5)
    .attr("ry", 5)
    .attr("fill", d => d.color)
    .attr("stroke", "#333333")
    .attr("stroke-width", 2)
    .on("mouseover", function(event, d) {
      d3.select(this)
        .attr("stroke", "#ff7700")
        .attr("stroke-width", 3);
    })
    .on("mouseout", function(event, d) {
      d3.select(this)
        .attr("stroke", "#333333")
        .attr("stroke-width", 2);
    });

  // Add node text with word wrapping
  nodeGroup.append("text")
    .text(d => d.question)
    .attr("text-anchor", "middle")
    .attr("alignment-baseline", "middle")
    .style("fill", "#333333")
    .style("font-size", "12px")
    .each(function(d) {
      const text = d3.select(this);
      const words = d.question.split(/\s+/);
      const lineHeight = 1.2;
      const maxWidth = 120;
      
      text.text('');
      let line = [];
      let lineNumber = 0;
      let tspan = text.append("tspan")
        .attr("x", 0)
        .attr("dy", 0);
      
      words.forEach(word => {
        line.push(word);
        tspan.text(line.join(" "));
        
        if (tspan.node().getComputedTextLength() > maxWidth) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan")
            .attr("x", 0)
            .attr("dy", `${lineHeight}em`)
            .text(word);
          lineNumber++;
        }
      });
      
      const totalHeight = (lineNumber * lineHeight) / 2;
      text.selectAll("tspan")
        .attr("dy", (_, i) => `${i === 0 ? -totalHeight : lineHeight}em`);
    });





    
  // Add padding to rectangles based on text size
  const rectPadding = 20;
  const minWidth = 40;
  const minHeight = 40;
  
  nodeGroup.each(function() {
    const g = d3.select(this);
    const text = g.select("text");
    const bbox = text.node().getBBox();
    
    g.select("rect")
      .attr("x", bbox.x - rectPadding / 2)
      .attr("y", bbox.y - rectPadding / 2)
      .attr("width", Math.max(bbox.width + rectPadding, minWidth))
      .attr("height", Math.max(bbox.height + rectPadding, minHeight));
  });

  // Add category labels
  nodeGroup.append("text")
    .attr("class", "category")
    .text(d => d.category || "")
    .attr("text-anchor", "middle")
    .attr("y", function(d) {
      const rect = d3.select(this.parentNode).select("rect");
      return parseFloat(rect.attr("y")) - 10;
    })
    .attr("fill", "#805ad5")
    .style("font-size", "10px")
    .style("font-weight", "bold");

  // Force simulation setup
  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(validLinks).id(d => d.id).distance(150))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(width / 2, height / 2));

  // Run simulation for a fixed number of ticks
  for (let i = 0; i < 300; ++i) simulation.tick();
  simulation.stop();
  
  // Fix node positions after simulation
  nodes.forEach(n => { 
    n.fx = n.x; 
    n.fy = n.y; 
  });

  // Update positions of all elements
  function updatePositions() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);
    
    nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
  }
  
  updatePositions();

  // Drag functions
  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  
  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
    updatePositions();
  }
  
  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = event.x;
    d.fy = event.y;
    updatePositions();
  }




  
  // Add mind map controls
  const controls = container.append("div")
    .attr("class", "mind-map-controls")
    .style("position", "absolute")
    .style("bottom", "20px")
    .style("left", "20px")
    .style("z-index", "100");
  
  controls.append("button")
    .attr("class", "mind-map-button")
    .text("Reset View")
    .on("click", function() {
      svg.transition().duration(750).call(
        d3.zoom().transform,
        d3.zoomIdentity
      );
    });
  
  controls.append("button")
    .attr("class", "mind-map-button")
    .text("Auto Layout")
    .on("click", function() {
      // Release fixed positions
      nodes.forEach(n => { 
        n.fx = null; 
        n.fy = null; 
      });
      
      // Restart simulation
      simulation.alpha(1).restart();
      
      // Update during simulation
      simulation.on("tick", updatePositions);
      
      // Stop and fix positions after simulation
      setTimeout(() => {
        simulation.stop();
        nodes.forEach(n => { 
          n.fx = n.x; 
          n.fy = n.y; 
        });
      }, 2000);
    });
}

function toggleMindMapView() {
  const gridView = document.getElementById('gridView');
  const mindMapView = document.getElementById('mindMapView');
  const toggleBtn = document.getElementById('toggleViewBtn');
  if (mindMapView.style.display === "none") {
    gridView.style.display = "none";
    mindMapView.style.display = "block";
    toggleBtn.textContent = "Grid View";
    renderMindMap(currentFilteredCards, connections);
    // Initialize context menu after rendering the mind map
    addMindMapContextMenu();
  } else {
    mindMapView.style.display = "none";
    gridView.style.display = "block";
    toggleBtn.textContent = "Mind Map View";
  }
}

function editConnection(connId, cards) {
  const conn = connections.find(c => c.id === connId);
  if (conn) {
    const newDesc = prompt('Edit connection description:', conn.description);
    if (newDesc !== null) {
      conn.description = newDesc;
      saveConnections();
      renderConnexionCanvas(cards);
    }
  }
}

function viewConnection(connId, cards) {
  const conn = connections.find(c => c.id === connId);
  if (conn) {
    const cardQuestions = conn.cards.map(id => {
      const card = cards.find(c => c.id === id);
      return card ? card.question : 'Unknown';
    }).join(', ');
    alert(`Connection Details:\n\nCards: ${cardQuestions}\nDescription: ${conn.description}`);
  }
}

function removeConnection(connId, cards) {
  if (confirm('Are you sure you want to remove this connection?')) {
    connections = connections.filter(c => c.id !== connId);
    saveConnections();
    renderConnexionCanvas(cards);
  }
}

/******************************

/******************************
 * Practice Mode Functions    *
 ******************************/
let practiceCards = [];
let currentCardIndex = 0;
let isMobileMode = false;

function toggleMobileMode() {
  isMobileMode = !isMobileMode;
  const switchBtn = document.getElementById('modeSwitchBtn');
  if (switchBtn) {
    switchBtn.textContent = isMobileMode ? 'Switch to Desktop Mode' : 'Switch to Mobile Mode';
  }
  updatePracticeDeck();
}

function startPracticeMode() {
  const flashcards = currentCards.filter(card => card.type === "card");
  if (flashcards.length === 0) return alert('No flashcards to practice!');
  document.getElementById('practiceDeck').style.display = 'flex';
  document.querySelector('.flashcard-container').style.display = 'none';
  document.querySelector('.input-panel').style.display = 'none';
  document.querySelector('.button-panel').style.display = 'none';
  

  if (!document.getElementById('modeSwitchBtn')) {
    const modeSwitchBtn = document.createElement('button');
    modeSwitchBtn.id = 'modeSwitchBtn';
    modeSwitchBtn.style.marginBottom = '20px';
    modeSwitchBtn.style.padding = '10px 15px';
    modeSwitchBtn.style.background = '#28a745';
    modeSwitchBtn.style.color = '#fff';
    modeSwitchBtn.style.border = 'none';
    modeSwitchBtn.style.borderRadius = '5px';
    modeSwitchBtn.style.cursor = 'pointer';
    modeSwitchBtn.textContent = 'Switch to Mobile Mode';
    modeSwitchBtn.onclick = toggleMobileMode;
    document.getElementById('practiceDeck').appendChild(modeSwitchBtn);
  }
  initializePracticeDeck(flashcards);
}

function exitPracticeMode() {
  document.getElementById('practiceDeck').style.display = 'none';
  document.querySelector('.flashcard-container').style.display = 'flex';
  document.querySelector('.input-panel').style.display = 'flex';
  document.querySelector('.button-panel').style.display = 'flex';
  
  // Force a refresh of the button panel to maintain layout
  resetButtonPanel();
}

function initializePracticeDeck(flashcards) {
  const container = document.getElementById('practiceDeckContainer');
  container.innerHTML = '';
  practiceCards = [];
  flashcards.forEach((card, index) => {
    const cardElement = document.createElement('div');
    cardElement.className = 'practice-card';
    cardElement.innerHTML = `
      <div class="practice-card-face practice-card-front">
        <h2>${card.category || 'General'}</h2>
        <p>${card.question}</p>
      </div>
      <div class="practice-card-face practice-card-back">
        ${card.answer}
      </div>
    `;
    cardElement.addEventListener('click', (e) => {
      const rect = cardElement.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const halfWidth = rect.width / 2;
      cardElement.classList.remove('flip-left', 'flip-right');
      if (clickX < halfWidth) {
        cardElement.classList.add('flip-left');
      } else {
        cardElement.classList.add('flip-right');
      }
      cardElement.classList.toggle('flipped');
      updatePracticeDeck();
      setTimeout(() => {
        if (window.MathJax) MathJax.typesetPromise();
      }, 500);
    });
    practiceCards.push(cardElement);
    container.appendChild(cardElement);
  });
  currentCardIndex = 0;
  updatePracticeDeck();
  if (window.MathJax) MathJax.typesetPromise();
}

function updatePracticeDeck() {
  practiceCards.forEach((card, index) => {
    const diffIndex = index - currentCardIndex;
    const offset = isMobileMode ? diffIndex * 30 : diffIndex * 50;
    const scale = isMobileMode ? 1 - Math.abs(diffIndex) * 0.05 : 1 - Math.abs(diffIndex) * 0.08;
    let transformStr = `translateX(${offset}px) scale(${scale})`;
    if (card.classList.contains('flipped')) {
      if (card.classList.contains('flip-left')) {
        transformStr += ' rotateY(-180deg) rotateX(-3deg)';
      } else {
        transformStr += ' rotateY(180deg) rotateX(3deg)';
      }
    }
    card.style.transform = transformStr;
    card.style.zIndex = practiceCards.length - Math.abs(diffIndex);
    card.classList.toggle('active', index === currentCardIndex);
    if (isMobileMode) {
      card.style.width = '90%';
      card.style.margin = '10px auto';
      card.style.fontSize = '1.5em';
    } else {
      card.style.width = '50%';
      card.style.height = '90%';
      card.style.margin = '';
      card.style.fontSize = '';
    }
  });
}

function showNextCard() {
  currentCardIndex = (currentCardIndex + 1) % practiceCards.length;
  updatePracticeDeck();
}

function showPrevCard() {
  currentCardIndex = (currentCardIndex - 1 + practiceCards.length) % practiceCards.length;
  updatePracticeDeck();
}

let touchStartX = 0;
document.getElementById('practiceDeckContainer').addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
});
document.getElementById('practiceDeckContainer').addEventListener('touchend', e => {
  const touchEndX = e.changedTouches[0].clientX;
  const diff = touchStartX - touchEndX;
  if (Math.abs(diff) > 50) {
    if (diff > 0) showNextCard();
    else showPrevCard();
  }
});
function initializePanelInteractions(element) {
  let isDragging = false;
  let currentX;
  let currentY;
  let initialX;
  let initialY;
  let xOffset = 0;
  let yOffset = 0;

  // Touch Events for all draggable elements
  element.addEventListener('touchstart', startDragging);
  element.addEventListener('touchmove', drag);
  element.addEventListener('touchend', stopDragging);
  element.addEventListener('touchcancel', stopDragging);

  // Mouse Events for desktop compatibility
  element.addEventListener('mousedown', startDragging);
  element.addEventListener('mousemove', drag);
  element.addEventListener('mouseup', stopDragging);
  element.addEventListener('mouseleave', stopDragging);

  function startDragging(e) {
    if (e.type === 'mousedown') {
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;
    } else if (e.type === 'touchstart') {
      initialX = e.touches[0].clientX - xOffset;
      initialY = e.touches[0].clientY - yOffset;
    }

    if (e.target === element || e.target.parentElement === element) {
      isDragging = true;
    }
  }

  function drag(e) {
    if (isDragging) {
      e.preventDefault();

      if (e.type === 'mousemove') {
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
      } else if (e.type === 'touchmove') {
        currentX = e.touches[0].clientX - initialX;
        currentY = e.touches[0].clientY - initialY;
      }

      xOffset = currentX;
      yOffset = currentY;

      setTranslate(currentX, currentY, element);
    }
  }

  function stopDragging() {
    isDragging = false;
  }

  function setTranslate(xPos, yPos, el) {
    el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
  }
}

function createConnexionCard(card) {
  const cardElement = document.createElement('div');
  cardElement.className = 'connexion-card';
  cardElement.dataset.id = card.id; // Changed from cardId to id to match detection logic
  
  cardElement.innerHTML = `
    <h4>${card.question}</h4>
    <p>${card.category || ''}</p>
  `;

  // Make the card draggable
  let isDragging = false;
  let startX, startY;

  cardElement.addEventListener('mousedown', startDrag);
  cardElement.addEventListener('touchstart', startDrag);
  
  function startDrag(e) {
    isDragging = true;
    if (e.type === 'mousedown') {
      startX = e.clientX - cardElement.offsetLeft;
      startY = e.clientY - cardElement.offsetTop;
    } else if (e.type === 'touchstart') {
      startX = e.touches[0].clientX - cardElement.offsetLeft;
      startY = e.touches[0].clientY - cardElement.offsetTop;
    }
    cardElement.style.zIndex = '1000';
  }

  cardElement.addEventListener('mousemove', drag);
  cardElement.addEventListener('touchmove', drag);

  function drag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    let currentX, currentY;
    if (e.type === 'mousemove') {
      currentX = e.clientX - startX;
      currentY = e.clientY - startY;
    } else if (e.type === 'touchmove') {
      currentX = e.touches[0].clientX - startX;
      currentY = e.touches[0].clientY - startY;
    }

    cardElement.style.left = `${currentX}px`;
    cardElement.style.top = `${currentY}px`;
    
    // Check for nearby cards while dragging
    highlightNearbyCards(card, currentX, currentY);
  }

  cardElement.addEventListener('mouseup', endDrag);
  cardElement.addEventListener('touchend', endDrag);

  function endDrag() {
    if (isDragging) {
      isDragging = false;
      cardElement.style.zIndex = '1';
      detectAndCreateConnections(card, currentFilteredCards);
    }
  }

  return cardElement;
}

function highlightNearbyCards(draggedCard, x, y) {
  const draggedElem = document.querySelector(`.connexion-card[data-id="${draggedCard.id}"]`);
  if (!draggedElem) return;

  const draggedRect = draggedElem.getBoundingClientRect();
  
  document.querySelectorAll('.connexion-card').forEach(cardElem => {
    if (cardElem.dataset.id === draggedCard.id) return;
    
    const cardRect = cardElem.getBoundingClientRect();
    const distance = Math.sqrt(
      Math.pow((draggedRect.left + draggedRect.width/2) - (cardRect.left + cardRect.width/2), 2) +
      Math.pow((draggedRect.top + draggedRect.height/2) - (cardRect.top + cardRect.height/2), 2)
    );

    if (distance < 150) {
      cardElem.classList.add('can-connect');
    } else {
      cardElem.classList.remove('can-connect');
    }
  });
}
document.addEventListener('DOMContentLoaded', function() {
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', toggleFullscreenView);
    }
});



function toggleFullscreenView() {
  const container = document.querySelector('.flashcard-container');
  const isFullscreen = document.fullscreenElement;
  
  if (!isFullscreen) {
    // Enter fullscreen
    if (container.requestFullscreen) {
      container.requestFullscreen();
    } else if (container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen();
    } else if (container.msRequestFullscreen) {
      container.msRequestFullscreen();
    }
    
    container.classList.add('fullscreen-mode');
    
    // Create dropdown menu
    const dropdown = document.createElement('div');
    dropdown.className = 'fs-dropdown';
    dropdown.innerHTML = `
      <button class="fs-dropdown-btn">
        <span>Menu</span>
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2 5L8 11L14 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <div class="fs-dropdown-content">
        <div class="fs-dropdown-item" id="fs-nav-prev">
          <i>⬅️</i> Previous Card
        </div>
        <div class="fs-dropdown-item" id="fs-nav-next">
          <i>➡️</i> Next Card
        </div>
        <div class="fs-dropdown-item" id="fs-flip-all">
          <i>🔄</i> Flip All Cards
        </div>
        <div class="fs-dropdown-item" id="fs-category-sort">
          <i>📊</i> Sort by Category
        </div>
        <div class="fs-dropdown-item" id="fs-presentation">
          <i>▶️</i> Presentation Mode
        </div>
        <div class="fs-dropdown-item" id="fs-theme-toggle">
          <i>🌓</i> Toggle Dark Mode
        </div>
        <div class="fs-dropdown-item" id="fs-search">
          <i>🔍</i> Search Cards
        </div>
        <div class="fs-dropdown-item" id="fs-exit">
          <i>❌</i> Exit Fullscreen
        </div>
      </div>
    `;
    container.appendChild(dropdown);
    
    // Create category panels container (initially hidden)
    const categoryPanelsContainer = document.createElement('div');
    categoryPanelsContainer.className = 'category-panels-container';
    container.appendChild(categoryPanelsContainer);
    
    // Create back button for category view
    const backBtn = document.createElement('button');
    backBtn.className = 'category-view-back';
    backBtn.textContent = 'Back to All Cards';
    backBtn.onclick = exitCategoryView;
    container.appendChild(backBtn);
    
    // Create exit button
    const exitBtn = document.createElement('button');
    exitBtn.className = 'exit-fullscreen-btn';
    exitBtn.innerHTML = 'Exit Fullscreen';
    exitBtn.onclick = toggleFullscreenView;
    container.appendChild(exitBtn);

    // Initialize fullscreen controls
    initFullscreenControls();

    // Ensure all cards are visible and properly styled
    const cards = container.querySelectorAll('.flashcard');
    cards.forEach(card => {
      card.style.display = 'block';
      card.style.opacity = '1';
      card.style.position = 'relative';
      card.style.left = 'auto';
      card.style.top = 'auto';
      
      // Hide expand button in fullscreen mode
      const expandBtn = card.querySelector('.expand-btn');
      if (expandBtn) {
        expandBtn.style.display = 'none';
      }
    });
    
    // Add keyboard navigation
    document.addEventListener('keydown', handleFullscreenKeyboard);
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
    
    container.classList.remove('fullscreen-mode');
    
    // Remove fullscreen controls and exit button
    const dropdown = container.querySelector('.fs-dropdown');
    if (dropdown) dropdown.remove();
    
    const exitBtn = container.querySelector('.exit-fullscreen-btn');
    if (exitBtn) exitBtn.remove();
    
    const categoryPanelsContainer = container.querySelector('.category-panels-container');
    if (categoryPanelsContainer) categoryPanelsContainer.remove();
    
    const backBtn = container.querySelector('.category-view-back');
    if (backBtn) backBtn.remove();
    
    // Reset card styles
    const cards = container.querySelectorAll('.flashcard');
    cards.forEach(card => {
      card.style.transform = '';
      card.style.transition = '';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';
      
      // Show expand button again when exiting fullscreen
      const expandBtn = card.querySelector('.expand-btn');
      if (expandBtn) {
        expandBtn.style.display = '';
      }
    });
    
    // Reset button panel layout when exiting fullscreen
    resetButtonPanel();
    
    // Remove keyboard event listener
    document.removeEventListener('keydown', handleFullscreenKeyboard);
  }
}


// Initialize fullscreen controls
function initFullscreenControls() {
  const container = document.querySelector('.flashcard-container');
  let currentIndex = 0;
  let presentationMode = false;
  let presentationTimer = null;
  
  // Toggle dropdown menu
  const dropdownBtn = document.querySelector('.fs-dropdown-btn');
  const dropdownContent = document.querySelector('.fs-dropdown-content');
  
  dropdownBtn.addEventListener('click', () => {
    dropdownContent.classList.toggle('show');
  });
  
  // Close dropdown when clicking outside
  window.addEventListener('click', (e) => {
    if (!e.target.matches('.fs-dropdown-btn') && !e.target.closest('.fs-dropdown-btn')) {
      dropdownContent.classList.remove('show');
    }
  });
  
  // Navigation buttons
  document.getElementById('fs-nav-prev').addEventListener('click', () => {
    navigateCards(-1);
    dropdownContent.classList.remove('show');
  });
  
  document.getElementById('fs-nav-next').addEventListener('click', () => {
    navigateCards(1);
    dropdownContent.classList.remove('show');
  });
  
  // Flip all cards
  document.getElementById('fs-flip-all').addEventListener('click', () => {
    const cards = container.querySelectorAll('.flashcard');
    cards.forEach(card => {
      card.classList.toggle('flipped');
    });
    
    // Render LaTeX if needed
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([container]).catch(err => console.log(err.message));
      }
    }, 500);
    
    dropdownContent.classList.remove('show');
  });
  
  // Sort by category
  document.getElementById('fs-category-sort').addEventListener('click', () => {
    sortByCategory();
    dropdownContent.classList.remove('show');
  });
  
  // Presentation mode
  document.getElementById('fs-presentation').addEventListener('click', (e) => {
    presentationMode = !presentationMode;
    e.target.innerHTML = presentationMode ? 
      '<i>⏹️</i> Stop Presentation' : 
      '<i>▶️</i> Presentation Mode';
    
    if (presentationMode) {
      // Start auto-flipping cards every 5 seconds
      presentationTimer = setInterval(() => {
        const visibleCards = Array.from(container.querySelectorAll('.flashcard:not(.hidden)'));
        if (currentIndex >= visibleCards.length) currentIndex = 0;
        
        // Flip current card if not already flipped
        if (!visibleCards[currentIndex].classList.contains('flipped')) {
          visibleCards[currentIndex].classList.add('flipped');
          
          // Render LaTeX if needed
          setTimeout(() => {
            if (window.MathJax) {
              MathJax.typesetPromise([visibleCards[currentIndex]]).catch(err => console.log(err.message));
            }
          }, 500);
          
          // Wait 3 seconds before moving to next card
          setTimeout(() => {
            currentIndex++;
          }, 3000);
        } else {
          // If already flipped, move to next card
          visibleCards[currentIndex].classList.remove('flipped');
          currentIndex++;
        }
      }, 5000);
    } else {
      // Stop auto-flipping
      clearInterval(presentationTimer);
    }
    
    dropdownContent.classList.remove('show');
  });
  
  // Theme toggle
  document.getElementById('fs-theme-toggle').addEventListener('click', (e) => {
    container.classList.toggle('dark-theme');
    e.target.innerHTML = container.classList.contains('dark-theme') ? 
      '<i>☀️</i> Light Mode' : 
      '<i>🌓</i> Dark Mode';
    
    dropdownContent.classList.remove('show');
  });
  
  // Search cards
  document.getElementById('fs-search').addEventListener('click', () => {
    const searchTerm = prompt('Enter search term:');
    if (searchTerm) {
      searchCards(searchTerm);
    }
    
    dropdownContent.classList.remove('show');
  });
  
  // Exit fullscreen
  document.getElementById('fs-exit').addEventListener('click', () => {
    toggleFullscreenView();
    dropdownContent.classList.remove('show');
  });
  
  function navigateCards(direction) {
    const visibleCards = Array.from(container.querySelectorAll('.flashcard:not(.hidden)'));
    if (visibleCards.length === 0) return;
    
    // Highlight current card
    visibleCards.forEach(card => card.classList.remove('current-card'));
    
    currentIndex = (currentIndex + direction + visibleCards.length) % visibleCards.length;
    visibleCards[currentIndex].classList.add('current-card');
    
    // Scroll to the card
    visibleCards[currentIndex].scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    });
  }
}

// Handle keyboard navigation in fullscreen mode
function handleFullscreenKeyboard(e) {
  if (!document.fullscreenElement) return;
  
  switch(e.key) {
    case 'ArrowRight':
    case 'ArrowDown':
      document.getElementById('fs-nav-next').click();
      break;
    case 'ArrowLeft':
    case 'ArrowUp':
      document.getElementById('fs-nav-prev').click();
      break;
    case ' ':
      // Space bar to flip current card
      const currentCard = document.querySelector('.flashcard.current-card');
      if (currentCard) {
        currentCard.classList.toggle('flipped');
        setTimeout(() => {
          if (window.MathJax) {
            MathJax.typesetPromise([currentCard]).catch(err => console.log(err.message));
          }
        }, 500);
      }
      break;
    case 'Escape':
      toggleFullscreenView();
      break;
  }
}



// Sort cards by category with animation
function sortByCategory() {
  const container = document.querySelector('.flashcard-container');
  const categoryPanelsContainer = container.querySelector('.category-panels-container');
  const backBtn = container.querySelector('.category-view-back');
  
  // Get all cards and their categories
  const cards = Array.from(container.querySelectorAll('.flashcard'));
  const categories = new Set();
  
  cards.forEach(card => {
    const categoryElement = card.querySelector('.flashcard-front div:first-child');
    const category = categoryElement ? categoryElement.textContent.trim() : 'Uncategorized';
    categories.add(category);
  });
  
  // Clear previous panels
  categoryPanelsContainer.innerHTML = '';
  
  // Create panels for each category with improved styling
  const categoryArray = Array.from(categories);
  
  // Calculate optimal panel layout based on number of categories
  const numCategories = categoryArray.length;
  let cols = 3; // Default to 3 columns
  
  if (numCategories <= 2) cols = 2;
  if (numCategories === 1) cols = 1;
  
  const rows = Math.ceil(numCategories / cols);
  const panelWidth = Math.floor(100 / cols);
  const panelHeight = Math.floor(100 / rows);
  
  categoryArray.forEach((category, index) => {
    const panel = document.createElement('div');
    panel.className = 'category-panel';
    panel.innerHTML = `<div class="category-panel-header">${category}</div><div class="category-cards-container"></div>`;
    
    // Position panel
    const row = Math.floor(index / cols);
    const col = index % cols;
    
    panel.style.width = `${panelWidth}%`;
    panel.style.height = `${panelHeight}%`;
    panel.style.left = `${col * panelWidth}%`;
    panel.style.top = `${row * panelHeight}%`;
    panel.style.background = `linear-gradient(135deg, rgba(25,25,35,0.8), rgba(35,35,60,0.9))`;
    panel.style.backdropFilter = 'blur(10px)';
    panel.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3), inset 0 0 0 1px rgba(255,255,255,0.1)';
    
    categoryPanelsContainer.appendChild(panel);
  });
  
  // Show category panels container and back button
  categoryPanelsContainer.style.display = 'block';
  backBtn.style.display = 'block';
  
  // Group cards by category
  const cardsByCategory = {};
  cards.forEach(card => {
    const categoryElement = card.querySelector('.flashcard-front div:first-child');
    const category = categoryElement ? categoryElement.textContent.trim() : 'Uncategorized';
    
    if (!cardsByCategory[category]) {
      cardsByCategory[category] = [];
    }
    cardsByCategory[category].push(card);
  });
  
  // Add cards to their respective panels with improved layout
  Object.entries(cardsByCategory).forEach(([category, categoryCards]) => {
    const targetPanel = Array.from(categoryPanelsContainer.querySelectorAll('.category-panel'))
      .find(panel => panel.querySelector('.category-panel-header').textContent === category);
    
    if (targetPanel) {
      const cardsContainer = targetPanel.querySelector('.category-cards-container');
      cardsContainer.style.display = 'flex';
      cardsContainer.style.flexWrap = 'wrap';
      cardsContainer.style.justifyContent = 'center';
      cardsContainer.style.alignItems = 'flex-start';
      cardsContainer.style.gap = '15px';
      cardsContainer.style.padding = '15px';
      cardsContainer.style.overflowY = 'auto';
      cardsContainer.style.maxHeight = 'calc(100% - 60px)';
      
      // Calculate optimal card size based on number of cards
      const cardCount = categoryCards.length;
      let cardScale = 0.8; // Default scale
      
      if (cardCount > 8) cardScale = 0.6;
      if (cardCount > 16) cardScale = 0.5;
      if (cardCount > 24) cardScale = 0.4;
      
      categoryCards.forEach((card, idx) => {
        // Store original position
        const cardRect = card.getBoundingClientRect();
        card.dataset.originalLeft = card.style.left || '0px';
        card.dataset.originalTop = card.style.top || '0px';
        
        // Set card index for staggered animation
        card.style.setProperty('--card-index', idx);
        
        // Clone the card to avoid DOM manipulation issues
        const cardClone = card.cloneNode(true);
        cardClone.style.position = 'relative';
        cardClone.style.left = '0';
        cardClone.style.top = '0';
        cardClone.style.margin = '0';
        cardClone.style.transform = `scale(${cardScale})`;
        cardClone.style.transformOrigin = 'center top';
        cardClone.style.width = '200px';
        cardClone.style.height = '250px';
        cardClone.style.opacity = '0';
        cardClone.style.transition = 'all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1)';
        cardClone.dataset.originalCard = card.dataset.cardId;
        
        // Add click handler to flip card
        cardClone.addEventListener('click', () => {
          cardClone.classList.toggle('flipped');
          setTimeout(() => {
            if (window.MathJax) {
              MathJax.typesetPromise([cardClone]).catch(err => console.log(err.message));
            }
          }, 300);
        });
        
        // Add the clone to the panel
        cardsContainer.appendChild(cardClone);
        
        // Hide the original card
        card.style.display = 'none';
        
        // Animate the clone with staggered delay
        setTimeout(() => {
          cardClone.style.opacity = '1';
          cardClone.style.transform = `scale(${cardScale})`;
        }, 50 + idx * 50);
      });
      
      // Add active class to panel to trigger animations
      setTimeout(() => {
        targetPanel.classList.add('active');
      }, 100);
    }
  });
}

// Exit category view and return to normal fullscreen view
function exitCategoryView() {
  const container = document.querySelector('.flashcard-container');
  const categoryPanelsContainer = container.querySelector('.category-panels-container');
  const backBtn = container.querySelector('.category-view-back');
  
  // Hide panels and back button
  categoryPanelsContainer.style.display = 'none';
  backBtn.style.display = 'none';
  
  // Show all original cards
  const cards = Array.from(container.querySelectorAll('.flashcard'));
  cards.forEach((card) => {
    card.style.display = 'block';
    card.style.position = 'relative';
    card.style.left = 'auto';
    card.style.top = 'auto';
    card.style.margin = '';
    card.style.transform = '';
    card.style.transition = '';
    card.style.opacity = '1';
  });
  
  // Clear panels container
  setTimeout(() => {
    categoryPanelsContainer.innerHTML = '';
  }, 500);
}

// ... existing code ...

// Search cards in fullscreen mode
function searchCards(term) {
  if (!term) {
    // If no search term, show all cards
    const cards = document.querySelectorAll('.flashcard-container .flashcard');
    cards.forEach(card => {
      card.style.display = 'block';
      card.classList.remove('hidden');
    });
    return;
  }
  
  const container = document.querySelector('.flashcard-container');
  const cards = container.querySelectorAll('.flashcard');
  const termLower = term.toLowerCase();
  
  // Search through cards
  cards.forEach(card => {
    const frontContent = card.querySelector('.flashcard-front').textContent.toLowerCase();
    const backContent = card.querySelector('.flashcard-back').textContent.toLowerCase();
    
    if (frontContent.includes(termLower) || backContent.includes(termLower)) {
      card.style.display = 'block';
      card.classList.remove('hidden');
      
      // Highlight the card briefly
      card.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.8)';
      setTimeout(() => {
        card.style.boxShadow = '';
      }, 1500);
    } else {
      card.style.display = 'none';
      card.classList.add('hidden');
    }
  });
}

// Add fadeInScale animation for dropdown menu
document.head.insertAdjacentHTML('beforeend', `
  
    <style>
    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.9);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    /* Dark theme for fullscreen mode */
    .fullscreen-mode.dark-theme {
      background: linear-gradient(125deg, #000000, #121212, #1e1e1e);
    }
    
    .fullscreen-mode.dark-theme .flashcard-front {
      background: linear-gradient(135deg, #2d3436, #636e72);
      color: #f5f5f5;
    }
    
    .fullscreen-mode.dark-theme .flashcard-back {
      background: linear-gradient(135deg, #2c3e50, #34495e);
      color: #f5f5f5;
    }
    
    /* Current card highlight */
    .flashcard.current-card {
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
      transform: scale(1.05) !important;
      z-index: 100;
    }
    
    /* Hidden cards */
    .flashcard.hidden {
      display: none !important;
    }
    
    /* Enhanced category panel styling */
    .category-panel {
      border-radius: 20px;
      transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
      overflow: hidden;
      transform: translateY(20px);
      opacity: 0.8;
      background-image: 
        radial-gradient(circle at 20% 30%, rgba(103, 126, 234, 0.15) 0%, transparent 25%),
        radial-gradient(circle at 80% 70%, rgba(118, 75, 162, 0.15) 0%, transparent 25%);
    }
    
    /* Subcards Panel Styling */
    .subcards-panel-container {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 90%;
      height: 90%;
      transform: translate(-50%, -50%) scale(0.95);
      background: rgba(13, 27, 42, 0.75);
      z-index: 3000;
      display: none;
      flex-direction: column;
      padding: 30px;
      box-sizing: border-box;
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
      backdrop-filter: blur(15px);
      border-radius: 24px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 
                 0 1px 2px rgba(255, 255, 255, 0.1) inset,
                 0 -1px 2px rgba(0, 0, 0, 0.2) inset;
      border: 1px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
    }
    
    .subcards-panel-container.active {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .subcards-panel-header {
      display: flex;
      align-items: center;
      padding: 15px 0;
      margin-bottom: 25px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      position: relative;
    }
    
    .subcards-panel-header h2 {
      margin: 0;
      color: #fff;
      font-size: 26px;
      flex-grow: 1;
      text-align: center;
      font-weight: 500;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .subcards-panel-back {
      padding: 12px 20px;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
      position: relative;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .subcards-panel-back:before {
      content: '✕';
      margin-right: 8px;
      font-size: 18px;
    }
    
    .subcards-panel-back:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(255, 107, 107, 0.6);
    }
    
    .subcards-panel-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 25px;
      justify-content: center;
      align-content: flex-start;
      overflow-y: auto;
      padding: 30px;
      flex-grow: 1;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 18px;
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(5px);
      margin: 0 10px;
    }
    
    .panel-subcard {
      transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      margin: 10px;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
    }
    
    .panel-subcard:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Glass overlay effect */
    .glass-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
      border-radius: 24px;
      z-index: -1;
    }
    
    .category-panel.active {
      transform: translateY(0);
      opacity: 1;
    }
    
    .category-panel-header {
      background: linear-gradient(90deg, rgba(103, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
      padding: 15px;
      font-size: 24px;
      font-weight: 600;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(5px);
    }
    
    .category-cards-container {
      animation: fadeIn 0.5s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .category-view-back {
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.8), rgba(255, 71, 87, 0.8));
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .category-view-back:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      background: linear-gradient(135deg, rgba(255, 135, 135, 0.9), rgba(255, 101, 101, 0.9));
    }
    
    /* Subcard edit mode styling */
    .flashcard.subcard.editing .flashcard-inner {
      transform: none;
      transition: none;
    }
    
    .flashcard.subcard.editing .edit-mode {
      background-color: #fff;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .flashcard.subcard.editing .edit-mode.expanded {
      max-height: 500px;
      opacity: 1;
    }
    
    .fullscreen-mode .flashcard .expand-btn,
    .fullscreen-mode .flashcard-front .expand-btn,
    .fullscreen-mode .flashcard-back .expand-btn {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }
    
    /* Hide expand buttons in category panels */
    .category-panel .flashcard .expand-btn,
    .category-panel .flashcard-front .expand-btn,
    .category-panel .flashcard-back .expand-btn {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }  
  </style>
`);

// Initialize fullscreen button
document.addEventListener('DOMContentLoaded', function() {
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  if (fullscreenBtn) {
    fullscreenBtn.addEventListener('click', toggleFullscreenView);
  }
});
window.onload = function() {
  loadCards();
  loadConnections();
};

// Add a new function to reset the button panel
function resetButtonPanel() {
  const buttonPanel = document.querySelector('.button-panel');
  
  // Store original classes and styles before modification
  if (!buttonPanel.dataset.originalClasses) {
    buttonPanel.dataset.originalClasses = buttonPanel.className;
    buttonPanel.dataset.originalStyle = buttonPanel.getAttribute('style');
  }

  // Restore original state from dataset
  buttonPanel.className = buttonPanel.dataset.originalClasses;
  buttonPanel.setAttribute('style', buttonPanel.dataset.originalStyle || '');
  
  // Force layout recalculation
  buttonPanel.style.display = 'none';
  buttonPanel.offsetHeight; // Trigger reflow
  buttonPanel.style.display = '';
}

document.addEventListener('DOMContentLoaded', function() {
    const mobileControlsTrigger = document.getElementById('mobile-controls-trigger');
    const buttonPanelWrapper = document.querySelector('.button-panel-wrapper');

    if (mobileControlsTrigger && buttonPanelWrapper) {
        mobileControlsTrigger.addEventListener('click', () => {
            buttonPanelWrapper.classList.toggle('mobile-controls-active');
        });
    }
});
</script> 
</body>
</html>
